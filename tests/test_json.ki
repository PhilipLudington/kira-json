/// Tests for the JSON library
/// Covers parsing, serialization, accessors, and transformations.

module test_json

import src.json.{ Json, JsonField, ParseError, JsonError, UnexpectedEof, UnexpectedToken, UnterminatedString, InvalidEscape, ControlChar, InvalidNumber, TrailingContent, MaxDepthExceeded, DuplicateKey, format_error, error_line, error_column, JNull, JBool, JNumber, JString, JArray, JObject, is_null, is_bool, is_number, is_string, is_array, is_object, type_name, as_string, as_number, as_int, as_bool, as_array, as_object, get_field, get_index, size, keys, values, stringify, stringify_pretty, parse, parse_with_max_depth, parse_strict, parse_strict_with_max_depth, default_max_depth, set_field, remove_field, merge, map_array, filter_array, filter_fields, make_field, equals, get_path, set_path, has_path, remove_path, PathError, format_path_error }

// =============================================================================
// Test Utilities
// =============================================================================

/// Asserts that a condition is true, with a message.
let assert_true: fn(bool, string) -> void = fn(condition: bool, message: string) -> void {
    assert(condition, message)
    return
}

/// Asserts that two strings are equal.
let assert_str_eq: fn(string, string, string) -> void =
    fn(actual: string, expected: string, message: string) -> void {
        assert(std.string.equals(actual, expected), message)
        return
    }

/// Asserts that two i32 values are equal.
let assert_i32_eq: fn(i32, i32, string) -> void =
    fn(actual: i32, expected: i32, message: string) -> void {
        assert(actual == expected, message)
        return
    }

/// Asserts that two f64 values are equal.
let assert_f64_eq: fn(f64, f64, string) -> void =
    fn(actual: f64, expected: f64, message: string) -> void {
        assert(actual == expected, message)
        return
    }

/// Asserts that an Option is Some.
let assert_some[T]: fn(Option[T], string) -> void = fn(opt: Option[T], message: string) -> void {
    match opt {
        Some(_) => { return }
        None => { assert(false, message) }
    }
    return
}

/// Asserts that an Option is None.
let assert_none[T]: fn(Option[T], string) -> void = fn(opt: Option[T], message: string) -> void {
    match opt {
        Some(_) => { assert(false, message) }
        None => { return }
    }
    return
}

/// Asserts that a Result is Ok.
let assert_ok[T, E]: fn(Result[T, E], string) -> void = fn(result: Result[T, E], message: string) -> void {
    match result {
        Ok(_) => { return }
        Err(_) => { assert(false, message) }
    }
    return
}

/// Asserts that a Result is Err.
let assert_err[T, E]: fn(Result[T, E], string) -> void = fn(result: Result[T, E], message: string) -> void {
    match result {
        Ok(_) => { assert(false, message) }
        Err(_) => { return }
    }
    return
}

// =============================================================================
// Type Checking Predicate Tests
// =============================================================================

let test_is_null_with_null: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JNull

    // Act
    let result: bool = is_null(value)

    // Assert
    assert_true(result, "JNull should be identified as null")
    return
}

let test_is_null_with_non_null: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JBool(true)

    // Act
    let result: bool = is_null(value)

    // Assert
    assert_true(not result, "JBool should not be identified as null")
    return
}

let test_is_bool_with_bool: fn() -> void = fn() -> void {
    // Arrange
    let value_true: Json = JBool(true)
    let value_false: Json = JBool(false)

    // Act & Assert
    assert_true(is_bool(value_true), "JBool(true) should be identified as bool")
    assert_true(is_bool(value_false), "JBool(false) should be identified as bool")
    return
}

let test_is_bool_with_non_bool: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JNumber(42.0)

    // Act
    let result: bool = is_bool(value)

    // Assert
    assert_true(not result, "JNumber should not be identified as bool")
    return
}

let test_is_number_with_number: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JNumber(3.14)

    // Act
    let result: bool = is_number(value)

    // Assert
    assert_true(result, "JNumber should be identified as number")
    return
}

let test_is_number_with_non_number: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JString("42")

    // Act
    let result: bool = is_number(value)

    // Assert
    assert_true(not result, "JString should not be identified as number")
    return
}

let test_is_string_with_string: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JString("hello")

    // Act
    let result: bool = is_string(value)

    // Assert
    assert_true(result, "JString should be identified as string")
    return
}

let test_is_string_with_empty_string: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JString("")

    // Act
    let result: bool = is_string(value)

    // Assert
    assert_true(result, "Empty JString should be identified as string")
    return
}

let test_is_array_with_array: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JArray(Cons(JNull, Nil))

    // Act
    let result: bool = is_array(value)

    // Assert
    assert_true(result, "JArray should be identified as array")
    return
}

let test_is_array_with_empty_array: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JArray(Nil)

    // Act
    let result: bool = is_array(value)

    // Assert
    assert_true(result, "Empty JArray should be identified as array")
    return
}

let test_is_object_with_object: fn() -> void = fn() -> void {
    // Arrange
    let field: JsonField = JsonField { key: "x", value: JNull }
    let value: Json = JObject(Cons(field, Nil))

    // Act
    let result: bool = is_object(value)

    // Assert
    assert_true(result, "JObject should be identified as object")
    return
}

let test_is_object_with_empty_object: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JObject(Nil)

    // Act
    let result: bool = is_object(value)

    // Assert
    assert_true(result, "Empty JObject should be identified as object")
    return
}

// =============================================================================
// Type Name Tests
// =============================================================================

let test_type_name_null: fn() -> void = fn() -> void {
    let result: string = type_name(JNull)
    assert_str_eq(result, "null", "type_name of JNull should be 'null'")
    return
}

let test_type_name_boolean: fn() -> void = fn() -> void {
    let result: string = type_name(JBool(true))
    assert_str_eq(result, "boolean", "type_name of JBool should be 'boolean'")
    return
}

let test_type_name_number: fn() -> void = fn() -> void {
    let result: string = type_name(JNumber(0.0))
    assert_str_eq(result, "number", "type_name of JNumber should be 'number'")
    return
}

let test_type_name_string: fn() -> void = fn() -> void {
    let result: string = type_name(JString(""))
    assert_str_eq(result, "string", "type_name of JString should be 'string'")
    return
}

let test_type_name_array: fn() -> void = fn() -> void {
    let result: string = type_name(JArray(Nil))
    assert_str_eq(result, "array", "type_name of JArray should be 'array'")
    return
}

let test_type_name_object: fn() -> void = fn() -> void {
    let result: string = type_name(JObject(Nil))
    assert_str_eq(result, "object", "type_name of JObject should be 'object'")
    return
}

// =============================================================================
// Value Extractor Tests
// =============================================================================

let test_as_string_with_string: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JString("hello")

    // Act
    let result: Option[string] = as_string(value)

    // Assert
    match result {
        Some(s) => { assert_str_eq(s, "hello", "as_string should extract 'hello'") }
        None => { assert(false, "as_string should return Some for JString") }
    }
    return
}

let test_as_string_with_non_string: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JNumber(42.0)

    // Act
    let result: Option[string] = as_string(value)

    // Assert
    assert_none[string](result, "as_string should return None for JNumber")
    return
}

let test_as_number_with_number: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JNumber(3.14)

    // Act
    let result: Option[f64] = as_number(value)

    // Assert
    match result {
        Some(n) => { assert_f64_eq(n, 3.14, "as_number should extract 3.14") }
        None => { assert(false, "as_number should return Some for JNumber") }
    }
    return
}

let test_as_number_with_non_number: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JString("3.14")

    // Act
    let result: Option[f64] = as_number(value)

    // Assert
    assert_none[f64](result, "as_number should return None for JString")
    return
}

let test_as_int_with_integer: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JNumber(42.0)

    // Act
    let result: Option[i64] = as_int(value)

    // Assert
    match result {
        Some(n) => { assert(n == 42, "as_int should extract 42") }
        None => { assert(false, "as_int should return Some for JNumber") }
    }
    return
}

let test_as_int_truncates_decimal: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JNumber(3.7)

    // Act
    let result: Option[i64] = as_int(value)

    // Assert - should truncate towards zero
    match result {
        Some(n) => { assert(n == 3, "as_int should truncate 3.7 to 3") }
        None => { assert(false, "as_int should return Some for JNumber") }
    }
    return
}

let test_as_bool_with_true: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JBool(true)

    // Act
    let result: Option[bool] = as_bool(value)

    // Assert
    match result {
        Some(b) => { assert_true(b, "as_bool should extract true") }
        None => { assert(false, "as_bool should return Some for JBool") }
    }
    return
}

let test_as_bool_with_false: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JBool(false)

    // Act
    let result: Option[bool] = as_bool(value)

    // Assert
    match result {
        Some(b) => { assert_true(not b, "as_bool should extract false") }
        None => { assert(false, "as_bool should return Some for JBool") }
    }
    return
}

let test_as_array_with_array: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JArray(Cons(JNull, Nil))

    // Act
    let result: Option[List[Json]] = as_array(value)

    // Assert
    assert_some[List[Json]](result, "as_array should return Some for JArray")
    return
}

let test_as_object_with_object: fn() -> void = fn() -> void {
    // Arrange
    let field: JsonField = JsonField { key: "x", value: JNull }
    let value: Json = JObject(Cons(field, Nil))

    // Act
    let result: Option[List[JsonField]] = as_object(value)

    // Assert
    assert_some[List[JsonField]](result, "as_object should return Some for JObject")
    return
}

// =============================================================================
// Field/Index Accessor Tests
// =============================================================================

let test_get_field_existing: fn() -> void = fn() -> void {
    // Arrange
    let field: JsonField = JsonField { key: "name", value: JString("Alice") }
    let obj: Json = JObject(Cons(field, Nil))

    // Act
    let result: Option[Json] = get_field(obj, "name")

    // Assert
    match result {
        Some(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "Alice", "get_field should return 'Alice'") }
                None => { assert(false, "Field value should be a string") }
            }
        }
        None => { assert(false, "get_field should find 'name' field") }
    }
    return
}

let test_get_field_non_existing: fn() -> void = fn() -> void {
    // Arrange
    let field: JsonField = JsonField { key: "name", value: JString("Alice") }
    let obj: Json = JObject(Cons(field, Nil))

    // Act
    let result: Option[Json] = get_field(obj, "age")

    // Assert
    assert_none[Json](result, "get_field should return None for non-existing key")
    return
}

let test_get_field_on_non_object: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JArray(Nil)

    // Act
    let result: Option[Json] = get_field(value, "name")

    // Assert
    assert_none[Json](result, "get_field should return None for non-object")
    return
}

let test_get_index_valid: fn() -> void = fn() -> void {
    // Arrange
    let arr: Json = JArray(Cons(
        JNumber(10.0),
        Cons(JNumber(20.0), Cons(JNumber(30.0), Nil))
    ))

    // Act
    let result: Option[Json] = get_index(arr, 1)

    // Assert
    match result {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 20.0, "get_index(1) should return 20.0") }
                None => { assert(false, "Element should be a number") }
            }
        }
        None => { assert(false, "get_index should find element at index 1") }
    }
    return
}

let test_get_index_out_of_bounds: fn() -> void = fn() -> void {
    // Arrange
    let arr: Json = JArray(Cons(JNumber(10.0), Nil))

    // Act
    let result: Option[Json] = get_index(arr, 5)

    // Assert
    assert_none[Json](result, "get_index should return None for out of bounds")
    return
}

let test_get_index_negative: fn() -> void = fn() -> void {
    // Arrange
    let arr: Json = JArray(Cons(JNumber(10.0), Nil))

    // Act
    let result: Option[Json] = get_index(arr, -1)

    // Assert
    assert_none[Json](result, "get_index should return None for negative index")
    return
}

let test_size_array: fn() -> void = fn() -> void {
    // Arrange
    let arr: Json = JArray(Cons(
        JNull,
        Cons(JNull, Cons(JNull, Nil))
    ))

    // Act
    let result: Option[i32] = size(arr)

    // Assert
    match result {
        Some(n) => { assert_i32_eq(n, 3, "size of 3-element array should be 3") }
        None => { assert(false, "size should return Some for array") }
    }
    return
}

let test_size_empty_array: fn() -> void = fn() -> void {
    // Arrange
    let arr: Json = JArray(Nil)

    // Act
    let result: Option[i32] = size(arr)

    // Assert
    match result {
        Some(n) => { assert_i32_eq(n, 0, "size of empty array should be 0") }
        None => { assert(false, "size should return Some for empty array") }
    }
    return
}

let test_size_object: fn() -> void = fn() -> void {
    // Arrange
    let field1: JsonField = JsonField { key: "a", value: JNull }
    let field2: JsonField = JsonField { key: "b", value: JNull }
    let obj: Json = JObject(Cons(field1, Cons(field2, Nil)))

    // Act
    let result: Option[i32] = size(obj)

    // Assert
    match result {
        Some(n) => { assert_i32_eq(n, 2, "size of 2-field object should be 2") }
        None => { assert(false, "size should return Some for object") }
    }
    return
}

let test_size_non_container: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JNumber(42.0)

    // Act
    let result: Option[i32] = size(value)

    // Assert
    assert_none[i32](result, "size should return None for non-container types")
    return
}

let test_keys_object: fn() -> void = fn() -> void {
    // Arrange
    let field1: JsonField = JsonField { key: "name", value: JNull }
    let field2: JsonField = JsonField { key: "age", value: JNull }
    let obj: Json = JObject(Cons(field1, Cons(field2, Nil)))

    // Act
    let result: Option[List[string]] = keys(obj)

    // Assert
    assert_some[List[string]](result, "keys should return Some for object")
    return
}

let test_keys_non_object: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JArray(Nil)

    // Act
    let result: Option[List[string]] = keys(value)

    // Assert
    assert_none[List[string]](result, "keys should return None for non-object")
    return
}

let test_values_object: fn() -> void = fn() -> void {
    // Arrange
    let field: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let obj: Json = JObject(Cons(field, Nil))

    // Act
    let result: Option[List[Json]] = values(obj)

    // Assert
    assert_some[List[Json]](result, "values should return Some for object")
    return
}

// =============================================================================
// Serialization Tests
// =============================================================================

let test_stringify_null: fn() -> void = fn() -> void {
    let result: string = stringify(JNull)
    assert_str_eq(result, "null", "stringify JNull should produce 'null'")
    return
}

let test_stringify_true: fn() -> void = fn() -> void {
    let result: string = stringify(JBool(true))
    assert_str_eq(result, "true", "stringify JBool(true) should produce 'true'")
    return
}

let test_stringify_false: fn() -> void = fn() -> void {
    let result: string = stringify(JBool(false))
    assert_str_eq(result, "false", "stringify JBool(false) should produce 'false'")
    return
}

let test_stringify_number_integer: fn() -> void = fn() -> void {
    let result: string = stringify(JNumber(42.0))
    // Note: float to string may vary, checking contains "42"
    assert_true(std.string.contains(result, "42"), "stringify should contain '42'")
    return
}

let test_stringify_string_simple: fn() -> void = fn() -> void {
    let result: string = stringify(JString("hello"))
    assert_str_eq(result, "\"hello\"", "stringify should quote strings")
    return
}

let test_stringify_string_with_quotes: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JString("hello \"world\"")

    // Act
    let result: string = stringify(value)

    // Assert
    assert_str_eq(result, "\"hello \\\"world\\\"\"", "stringify should escape quotes")
    return
}

let test_stringify_string_with_newline: fn() -> void = fn() -> void {
    // Arrange
    let value: Json = JString("line1\nline2")

    // Act
    let result: string = stringify(value)

    // Assert
    assert_str_eq(result, "\"line1\\nline2\"", "stringify should escape newlines")
    return
}

let test_stringify_empty_array: fn() -> void = fn() -> void {
    let result: string = stringify(JArray(Nil))
    assert_str_eq(result, "[]", "stringify empty array should produce '[]'")
    return
}

let test_stringify_array_with_elements: fn() -> void = fn() -> void {
    let arr: Json = JArray(Cons(
        JNumber(1.0),
        Cons(JNumber(2.0), Nil)
    ))
    let result: string = stringify(arr)
    assert_true(std.string.contains(result, "["), "stringify array should start with '['")
    assert_true(std.string.contains(result, "]"), "stringify array should end with ']'")
    assert_true(std.string.contains(result, ","), "stringify array should have comma separator")
    return
}

let test_stringify_empty_object: fn() -> void = fn() -> void {
    let result: string = stringify(JObject(Nil))
    assert_str_eq(result, "{}", "stringify empty object should produce '{}'")
    return
}

let test_stringify_object_with_fields: fn() -> void = fn() -> void {
    let field: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let obj: Json = JObject(Cons(field, Nil))
    let result: string = stringify(obj)
    assert_true(std.string.contains(result, "\"x\""), "stringify object should have quoted key")
    assert_true(std.string.contains(result, ":"), "stringify object should have colon")
    return
}

let test_stringify_pretty_indentation: fn() -> void = fn() -> void {
    let field: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let obj: Json = JObject(Cons(field, Nil))
    let result: string = stringify_pretty(obj)
    assert_true(std.string.contains(result, "\n"), "stringify_pretty should have newlines")
    assert_true(std.string.contains(result, "  "), "stringify_pretty should have indentation")
    return
}

// =============================================================================
// Parser Tests
// =============================================================================

let test_parse_null: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("null")
    match result {
        Ok(v) => { assert_true(is_null(v), "parse 'null' should produce JNull") }
        Err(_) => { assert(false, "parse 'null' should succeed") }
    }
    return
}

let test_parse_true: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("true")
    match result {
        Ok(v) => {
            match as_bool(v) {
                Some(b) => { assert_true(b, "parse 'true' should produce true") }
                None => { assert(false, "parse 'true' should produce bool") }
            }
        }
        Err(_) => { assert(false, "parse 'true' should succeed") }
    }
    return
}

let test_parse_false: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("false")
    match result {
        Ok(v) => {
            match as_bool(v) {
                Some(b) => { assert_true(not b, "parse 'false' should produce false") }
                None => { assert(false, "parse 'false' should produce bool") }
            }
        }
        Err(_) => { assert(false, "parse 'false' should succeed") }
    }
    return
}

let test_parse_integer: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("42")
    match result {
        Ok(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 42.0, "parse '42' should produce 42.0") }
                None => { assert(false, "parse '42' should produce number") }
            }
        }
        Err(_) => { assert(false, "parse '42' should succeed") }
    }
    return
}

let test_parse_negative_number: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("-17")
    match result {
        Ok(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, -17.0, "parse '-17' should produce -17.0") }
                None => { assert(false, "parse '-17' should produce number") }
            }
        }
        Err(_) => { assert(false, "parse '-17' should succeed") }
    }
    return
}

let test_parse_decimal: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("3.14")
    match result {
        Ok(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 3.14, "parse '3.14' should produce 3.14") }
                None => { assert(false, "parse '3.14' should produce number") }
            }
        }
        Err(_) => { assert(false, "parse '3.14' should succeed") }
    }
    return
}

let test_parse_exponent: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("1e10")
    match result {
        Ok(v) => { assert_true(is_number(v), "parse '1e10' should produce number") }
        Err(_) => { assert(false, "parse '1e10' should succeed") }
    }
    return
}

let test_parse_string_simple: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("\"hello\"")
    match result {
        Ok(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "hello", "parse '\"hello\"' should produce 'hello'") }
                None => { assert(false, "parse '\"hello\"' should produce string") }
            }
        }
        Err(_) => { assert(false, "parse '\"hello\"' should succeed") }
    }
    return
}

let test_parse_string_empty: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("\"\"")
    match result {
        Ok(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "", "parse '\"\"' should produce empty string") }
                None => { assert(false, "parse '\"\"' should produce string") }
            }
        }
        Err(_) => { assert(false, "parse '\"\"' should succeed") }
    }
    return
}

let test_parse_string_escaped_quote: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("\"hello \\\"world\\\"\"")
    match result {
        Ok(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "hello \"world\"", "parse escaped quote should work") }
                None => { assert(false, "should produce string") }
            }
        }
        Err(_) => { assert(false, "parse escaped quote should succeed") }
    }
    return
}

let test_parse_string_escaped_newline: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("\"line1\\nline2\"")
    match result {
        Ok(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "line1\nline2", "parse escaped newline should work") }
                None => { assert(false, "should produce string") }
            }
        }
        Err(_) => { assert(false, "parse escaped newline should succeed") }
    }
    return
}

let test_parse_array_empty: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("[]")
    match result {
        Ok(v) => {
            assert_true(is_array(v), "parse '[]' should produce array")
            match size(v) {
                Some(n) => { assert_i32_eq(n, 0, "parse '[]' should produce empty array") }
                None => { assert(false, "size should work on array") }
            }
        }
        Err(_) => { assert(false, "parse '[]' should succeed") }
    }
    return
}

let test_parse_array_with_elements: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("[1, 2, 3]")
    match result {
        Ok(v) => {
            assert_true(is_array(v), "parse '[1,2,3]' should produce array")
            match size(v) {
                Some(n) => { assert_i32_eq(n, 3, "parse '[1,2,3]' should have 3 elements") }
                None => { assert(false, "size should work on array") }
            }
        }
        Err(_) => { assert(false, "parse '[1,2,3]' should succeed") }
    }
    return
}

let test_parse_array_mixed_types: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("[1, \"hello\", true, null]")
    match result {
        Ok(v) => {
            assert_true(is_array(v), "parse mixed array should produce array")
            match size(v) {
                Some(n) => { assert_i32_eq(n, 4, "parse mixed array should have 4 elements") }
                None => { assert(false, "size should work on array") }
            }
        }
        Err(_) => { assert(false, "parse mixed array should succeed") }
    }
    return
}

let test_parse_object_empty: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("{}")
    match result {
        Ok(v) => {
            assert_true(is_object(v), "parse '{}' should produce object")
            match size(v) {
                Some(n) => { assert_i32_eq(n, 0, "parse '{}' should produce empty object") }
                None => { assert(false, "size should work on object") }
            }
        }
        Err(_) => { assert(false, "parse '{}' should succeed") }
    }
    return
}

let test_parse_object_single_field: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("{\"name\": \"Alice\"}")
    match result {
        Ok(v) => {
            assert_true(is_object(v), "parse object should produce object")
            match get_field(v, "name") {
                Some(val) => {
                    match as_string(val) {
                        Some(s) => { assert_str_eq(s, "Alice", "name field should be Alice") }
                        None => { assert(false, "name should be string") }
                    }
                }
                None => { assert(false, "should have name field") }
            }
        }
        Err(_) => { assert(false, "parse object should succeed") }
    }
    return
}

let test_parse_object_multiple_fields: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("{\"name\": \"Alice\", \"age\": 30}")
    match result {
        Ok(v) => {
            assert_true(is_object(v), "parse object should produce object")
            match size(v) {
                Some(n) => { assert_i32_eq(n, 2, "object should have 2 fields") }
                None => { assert(false, "size should work on object") }
            }
        }
        Err(_) => { assert(false, "parse object should succeed") }
    }
    return
}

let test_parse_nested_object: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("{\"user\": {\"name\": \"Alice\"}}")
    match result {
        Ok(v) => {
            assert_true(is_object(v), "parse nested object should produce object")
            match get_field(v, "user") {
                Some(user) => {
                    assert_true(is_object(user), "user field should be object")
                }
                None => { assert(false, "should have user field") }
            }
        }
        Err(_) => { assert(false, "parse nested object should succeed") }
    }
    return
}

let test_parse_with_whitespace: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("  { \"name\" : \"Alice\" }  ")
    match result {
        Ok(v) => {
            assert_true(is_object(v), "parse with whitespace should produce object")
        }
        Err(_) => { assert(false, "parse with whitespace should succeed") }
    }
    return
}

// Parser Error Tests

let test_parse_error_invalid_token: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("undefined")
    assert_err[Json, JsonError](result, "parse 'undefined' should fail")
    return
}

let test_parse_error_unterminated_string: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("\"hello")
    assert_err[Json, JsonError](result, "parse unterminated string should fail")
    return
}

let test_parse_error_unterminated_array: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("[1, 2")
    assert_err[Json, JsonError](result, "parse unterminated array should fail")
    return
}

let test_parse_error_unterminated_object: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("{\"name\": \"Alice\"")
    assert_err[Json, JsonError](result, "parse unterminated object should fail")
    return
}

let test_parse_error_trailing_content: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("true false")
    assert_err[Json, JsonError](result, "parse trailing content should fail")
    return
}

let test_parse_error_missing_colon: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("{\"name\" \"Alice\"}")
    assert_err[Json, JsonError](result, "parse missing colon should fail")
    return
}

let test_parse_error_position_tracking: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("{\n  \"name\": undefined\n}")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            // Error should be on line 2 where "undefined" is
            assert_i32_eq(error_line(e), 2, "error should be on line 2")
        }
    }
    return
}

// Number Edge Case Tests

let test_parse_number_leading_zero_rejected: fn() -> void = fn() -> void {
    // Leading zeros are invalid in JSON (except for "0" itself)
    let result: Result[Json, JsonError] = parse("007")
    assert_err[Json, JsonError](result, "parse '007' should fail - leading zeros not allowed")
    return
}

let test_parse_number_leading_zero_negative_rejected: fn() -> void = fn() -> void {
    // Leading zeros also invalid with negative sign
    let result: Result[Json, JsonError] = parse("-007")
    assert_err[Json, JsonError](result, "parse '-007' should fail - leading zeros not allowed")
    return
}

let test_parse_number_zero_alone_valid: fn() -> void = fn() -> void {
    // Single zero is valid
    let result: Result[Json, JsonError] = parse("0")
    match result {
        Ok(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 0.0, "parse '0' should produce 0.0") }
                None => { assert(false, "parse '0' should produce number") }
            }
        }
        Err(_) => { assert(false, "parse '0' should succeed") }
    }
    return
}

let test_parse_number_zero_decimal_valid: fn() -> void = fn() -> void {
    // Zero with decimal is valid
    let result: Result[Json, JsonError] = parse("0.5")
    match result {
        Ok(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 0.5, "parse '0.5' should produce 0.5") }
                None => { assert(false, "parse '0.5' should produce number") }
            }
        }
        Err(_) => { assert(false, "parse '0.5' should succeed") }
    }
    return
}

let test_parse_number_zero_exponent_valid: fn() -> void = fn() -> void {
    // Zero with exponent is valid
    let result: Result[Json, JsonError] = parse("0e5")
    match result {
        Ok(v) => { assert_true(is_number(v), "parse '0e5' should produce number") }
        Err(_) => { assert(false, "parse '0e5' should succeed") }
    }
    return
}

let test_parse_number_very_large_overflow: fn() -> void = fn() -> void {
    // Very large exponent should fail (infinity not allowed)
    let result: Result[Json, JsonError] = parse("1e999")
    assert_err[Json, JsonError](result, "parse '1e999' should fail - infinity not allowed")
    return
}

let test_parse_number_very_small_underflow: fn() -> void = fn() -> void {
    // Very small exponent underflows to zero, which is valid
    let result: Result[Json, JsonError] = parse("1e-999")
    match result {
        Ok(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 0.0, "parse '1e-999' should underflow to 0.0") }
                None => { assert(false, "parse '1e-999' should produce number") }
            }
        }
        Err(_) => { assert(false, "parse '1e-999' should succeed (underflow to 0)") }
    }
    return
}

let test_parse_number_negative_very_large: fn() -> void = fn() -> void {
    // Negative very large should also fail
    let result: Result[Json, JsonError] = parse("-1e999")
    assert_err[Json, JsonError](result, "parse '-1e999' should fail - infinity not allowed")
    return
}

let test_parse_number_scientific_notation_valid: fn() -> void = fn() -> void {
    // Normal scientific notation should work
    let result: Result[Json, JsonError] = parse("1.5e10")
    match result {
        Ok(v) => {
            match as_number(v) {
                Some(n) => {
                    // 1.5e10 = 15000000000.0
                    let expected: f64 = 15000000000.0
                    assert_f64_eq(n, expected, "parse '1.5e10' should work")
                }
                None => { assert(false, "parse '1.5e10' should produce number") }
            }
        }
        Err(_) => { assert(false, "parse '1.5e10' should succeed") }
    }
    return
}

let test_parse_number_negative_exponent_valid: fn() -> void = fn() -> void {
    // Negative exponent should work
    let result: Result[Json, JsonError] = parse("1.5e-5")
    match result {
        Ok(v) => {
            match as_number(v) {
                Some(n) => {
                    // 1.5e-5 = 0.000015
                    let expected: f64 = 0.000015
                    assert_f64_eq(n, expected, "parse '1.5e-5' should work")
                }
                None => { assert(false, "parse '1.5e-5' should produce number") }
            }
        }
        Err(_) => { assert(false, "parse '1.5e-5' should succeed") }
    }
    return
}

// String Validation Tests

let test_parse_string_with_escaped_tab_valid: fn() -> void = fn() -> void {
    // Escaped tab is valid
    let result: Result[Json, JsonError] = parse("\"hello\\tworld\"")
    match result {
        Ok(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "hello\tworld", "parse escaped tab should work") }
                None => { assert(false, "should produce string") }
            }
        }
        Err(_) => { assert(false, "parse escaped tab should succeed") }
    }
    return
}

let test_parse_string_with_escaped_backspace_valid: fn() -> void = fn() -> void {
    // Escaped backspace is valid
    let result: Result[Json, JsonError] = parse("\"hello\\bworld\"")
    match result {
        Ok(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "hello\bworld", "parse escaped backspace should work") }
                None => { assert(false, "should produce string") }
            }
        }
        Err(_) => { assert(false, "parse escaped backspace should succeed") }
    }
    return
}

let test_parse_string_with_escaped_formfeed_valid: fn() -> void = fn() -> void {
    // Escaped form feed is valid
    let result: Result[Json, JsonError] = parse("\"hello\\fworld\"")
    match result {
        Ok(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "hello\fworld", "parse escaped formfeed should work") }
                None => { assert(false, "should produce string") }
            }
        }
        Err(_) => { assert(false, "parse escaped formfeed should succeed") }
    }
    return
}

let test_parse_string_with_escaped_carriage_return_valid: fn() -> void = fn() -> void {
    // Escaped carriage return is valid
    let result: Result[Json, JsonError] = parse("\"hello\\rworld\"")
    match result {
        Ok(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "hello\rworld", "parse escaped carriage return should work") }
                None => { assert(false, "should produce string") }
            }
        }
        Err(_) => { assert(false, "parse escaped carriage return should succeed") }
    }
    return
}

let test_parse_string_with_unicode_escape_null_valid: fn() -> void = fn() -> void {
    // Unicode escape for null character is valid (produces the actual character)
    let result: Result[Json, JsonError] = parse("\"hello\\u0000world\"")
    assert_ok[Json, JsonError](result, "parse unicode escape for null should succeed")
    return
}

let test_parse_string_with_unicode_escape_control_valid: fn() -> void = fn() -> void {
    // Unicode escape for control characters is valid
    let result: Result[Json, JsonError] = parse("\"hello\\u001Fworld\"")
    assert_ok[Json, JsonError](result, "parse unicode escape for control char should succeed")
    return
}

// =============================================================================
// UTF-16 Surrogate Pair Tests
// =============================================================================

let test_parse_surrogate_pair_emoji_grinning_face: fn() -> void = fn() -> void {
    // \uD83D\uDE00 is the UTF-16 surrogate pair for grinning face emoji (U+1F600)
    let result: Result[Json, JsonError] = parse("\"\\uD83D\\uDE00\"")
    match result {
        Ok(json) => {
            match as_string(json) {
                Some(s) => {
                    // The grinning face emoji should be a 4-byte UTF-8 sequence
                    assert(std.string.length(s) == 4, "emoji should be 4 bytes in UTF-8")
                }
                None => { assert(false, "should be a string") }
            }
        }
        Err(_) => { assert(false, "parse surrogate pair should succeed") }
    }
    return
}

let test_parse_surrogate_pair_pile_of_poo: fn() -> void = fn() -> void {
    // \uD83D\uDCA9 is the UTF-16 surrogate pair for pile of poo emoji (U+1F4A9)
    let result: Result[Json, JsonError] = parse("\"\\uD83D\\uDCA9\"")
    match result {
        Ok(json) => {
            match as_string(json) {
                Some(s) => {
                    assert(std.string.length(s) == 4, "emoji should be 4 bytes in UTF-8")
                }
                None => { assert(false, "should be a string") }
            }
        }
        Err(_) => { assert(false, "parse surrogate pair should succeed") }
    }
    return
}

let test_parse_surrogate_pair_in_context: fn() -> void = fn() -> void {
    // Surrogate pair with surrounding text
    let result: Result[Json, JsonError] = parse("\"Hello \\uD83D\\uDE00 World\"")
    match result {
        Ok(json) => {
            match as_string(json) {
                Some(s) => {
                    // "Hello " (6) + emoji (4) + " World" (6) = 16 bytes
                    assert(std.string.length(s) == 16, "string with emoji should be 16 bytes")
                }
                None => { assert(false, "should be a string") }
            }
        }
        Err(_) => { assert(false, "parse surrogate pair in context should succeed") }
    }
    return
}

let test_parse_lone_high_surrogate_replaced: fn() -> void = fn() -> void {
    // A high surrogate not followed by a low surrogate should be replaced with U+FFFD
    let result: Result[Json, JsonError] = parse("\"\\uD83Dhello\"")
    match result {
        Ok(json) => {
            match as_string(json) {
                Some(s) => {
                    // U+FFFD is 3 bytes in UTF-8, plus "hello" (5 bytes) = 8 bytes
                    assert(std.string.length(s) == 8, "lone high surrogate + hello should be 8 bytes")
                }
                None => { assert(false, "should be a string") }
            }
        }
        Err(_) => { assert(false, "parse lone high surrogate should succeed with replacement") }
    }
    return
}

let test_parse_lone_low_surrogate_replaced: fn() -> void = fn() -> void {
    // A low surrogate not preceded by a high surrogate should be replaced with U+FFFD
    let result: Result[Json, JsonError] = parse("\"\\uDE00hello\"")
    match result {
        Ok(json) => {
            match as_string(json) {
                Some(s) => {
                    // U+FFFD is 3 bytes in UTF-8, plus "hello" (5 bytes) = 8 bytes
                    assert(std.string.length(s) == 8, "lone low surrogate + hello should be 8 bytes")
                }
                None => { assert(false, "should be a string") }
            }
        }
        Err(_) => { assert(false, "parse lone low surrogate should succeed with replacement") }
    }
    return
}

let test_parse_high_surrogate_at_end_replaced: fn() -> void = fn() -> void {
    // A high surrogate at the very end of the string should be replaced with U+FFFD
    let result: Result[Json, JsonError] = parse("\"hello\\uD83D\"")
    match result {
        Ok(json) => {
            match as_string(json) {
                Some(s) => {
                    // "hello" (5 bytes) + U+FFFD (3 bytes) = 8 bytes
                    assert(std.string.length(s) == 8, "hello + lone high surrogate should be 8 bytes")
                }
                None => { assert(false, "should be a string") }
            }
        }
        Err(_) => { assert(false, "parse high surrogate at end should succeed with replacement") }
    }
    return
}

let test_parse_high_surrogate_followed_by_non_surrogate: fn() -> void = fn() -> void {
    // High surrogate followed by a regular escape (not a low surrogate)
    let result: Result[Json, JsonError] = parse("\"\\uD83D\\u0041\"")
    match result {
        Ok(json) => {
            match as_string(json) {
                Some(s) => {
                    // U+FFFD (3 bytes) + "A" (1 byte) = 4 bytes
                    assert(std.string.length(s) == 4, "high surrogate + A should be 4 bytes")
                }
                None => { assert(false, "should be a string") }
            }
        }
        Err(_) => { assert(false, "parse high surrogate + non-surrogate should succeed") }
    }
    return
}

let test_parse_multiple_surrogate_pairs: fn() -> void = fn() -> void {
    // Multiple emoji in a row
    let result: Result[Json, JsonError] = parse("\"\\uD83D\\uDE00\\uD83D\\uDCA9\"")
    match result {
        Ok(json) => {
            match as_string(json) {
                Some(s) => {
                    // Two emoji, each 4 bytes = 8 bytes
                    assert(std.string.length(s) == 8, "two emoji should be 8 bytes")
                }
                None => { assert(false, "should be a string") }
            }
        }
        Err(_) => { assert(false, "parse multiple surrogate pairs should succeed") }
    }
    return
}

let test_parse_surrogate_pair_musical_symbol: fn() -> void = fn() -> void {
    // \uD834\uDD1E is G clef (U+1D11E), a common test case for surrogates
    let result: Result[Json, JsonError] = parse("\"\\uD834\\uDD1E\"")
    match result {
        Ok(json) => {
            match as_string(json) {
                Some(s) => {
                    // Musical symbols are 4 bytes in UTF-8
                    assert(std.string.length(s) == 4, "G clef should be 4 bytes in UTF-8")
                }
                None => { assert(false, "should be a string") }
            }
        }
        Err(_) => { assert(false, "parse G clef surrogate pair should succeed") }
    }
    return
}

let test_parse_string_unescaped_tab_rejected: fn() -> void = fn() -> void {
    // Unescaped tab (0x09) should be rejected
    // Tab is ASCII 9, which is a control character
    let input: string = "\"hello\tworld\""
    let result: Result[Json, JsonError] = parse(input)
    assert_err[Json, JsonError](result, "parse unescaped tab should fail")
    return
}

let test_parse_string_unescaped_newline_rejected: fn() -> void = fn() -> void {
    // Unescaped newline (0x0A) should be rejected
    let input: string = "\"hello\nworld\""
    let result: Result[Json, JsonError] = parse(input)
    assert_err[Json, JsonError](result, "parse unescaped newline should fail")
    return
}

let test_parse_string_unescaped_carriage_return_rejected: fn() -> void = fn() -> void {
    // Unescaped carriage return (0x0D) should be rejected
    let input: string = "\"hello\rworld\""
    let result: Result[Json, JsonError] = parse(input)
    assert_err[Json, JsonError](result, "parse unescaped carriage return should fail")
    return
}

let test_parse_string_invalid_escape_rejected: fn() -> void = fn() -> void {
    // Invalid escape sequence should be rejected
    let result: Result[Json, JsonError] = parse("\"hello\\xworld\"")
    assert_err[Json, JsonError](result, "parse invalid escape \\x should fail")
    return
}

let test_parse_string_bare_backslash_rejected: fn() -> void = fn() -> void {
    // Bare backslash at end of string should be rejected
    let result: Result[Json, JsonError] = parse("\"hello\\")
    assert_err[Json, JsonError](result, "parse bare backslash at end should fail")
    return
}

// =============================================================================
// Transformer Tests
// =============================================================================

let test_set_field_new: fn() -> void = fn() -> void {
    // Arrange
    let obj: Json = JObject(Nil)

    // Act
    let result: Json = set_field(obj, "x", JNumber(1.0))

    // Assert
    match get_field(result, "x") {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 1.0, "set_field should add new field") }
                None => { assert(false, "field should be number") }
            }
        }
        None => { assert(false, "set_field should create field") }
    }
    return
}

let test_set_field_update: fn() -> void = fn() -> void {
    // Arrange
    let field: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let obj: Json = JObject(Cons(field, Nil))

    // Act
    let result: Json = set_field(obj, "x", JNumber(99.0))

    // Assert
    match get_field(result, "x") {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 99.0, "set_field should update existing field") }
                None => { assert(false, "field should be number") }
            }
        }
        None => { assert(false, "field should exist") }
    }
    return
}

let test_set_field_on_non_object: fn() -> void = fn() -> void {
    // Arrange
    let arr: Json = JArray(Nil)

    // Act
    let result: Json = set_field(arr, "x", JNumber(1.0))

    // Assert
    assert_true(is_array(result), "set_field on non-object should return unchanged")
    return
}

let test_remove_field_existing: fn() -> void = fn() -> void {
    // Arrange
    let field1: JsonField = JsonField { key: "a", value: JNumber(1.0) }
    let field2: JsonField = JsonField { key: "b", value: JNumber(2.0) }
    let obj: Json = JObject(Cons(field1, Cons(field2, Nil)))

    // Act
    let result: Json = remove_field(obj, "a")

    // Assert
    assert_none[Json](get_field(result, "a"), "remove_field should remove 'a'")
    assert_some[Json](get_field(result, "b"), "remove_field should keep 'b'")
    return
}

let test_remove_field_non_existing: fn() -> void = fn() -> void {
    // Arrange
    let field: JsonField = JsonField { key: "a", value: JNumber(1.0) }
    let obj: Json = JObject(Cons(field, Nil))

    // Act
    let result: Json = remove_field(obj, "nonexistent")

    // Assert
    match size(result) {
        Some(n) => { assert_i32_eq(n, 1, "remove non-existing should not change size") }
        None => { assert(false, "should be object") }
    }
    return
}

let test_merge_objects: fn() -> void = fn() -> void {
    // Arrange
    let field_a: JsonField = JsonField { key: "a", value: JNumber(1.0) }
    let field_b: JsonField = JsonField { key: "b", value: JNumber(2.0) }
    let obj1: Json = JObject(Cons(field_a, Nil))
    let obj2: Json = JObject(Cons(field_b, Nil))

    // Act
    let result: Json = merge(obj1, obj2)

    // Assert
    assert_some[Json](get_field(result, "a"), "merge should keep 'a'")
    assert_some[Json](get_field(result, "b"), "merge should add 'b'")
    return
}

let test_merge_override: fn() -> void = fn() -> void {
    // Arrange
    let field1: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let field2: JsonField = JsonField { key: "x", value: JNumber(99.0) }
    let obj1: Json = JObject(Cons(field1, Nil))
    let obj2: Json = JObject(Cons(field2, Nil))

    // Act
    let result: Json = merge(obj1, obj2)

    // Assert
    match get_field(result, "x") {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 99.0, "merge should override with second object") }
                None => { assert(false, "field should be number") }
            }
        }
        None => { assert(false, "field should exist") }
    }
    return
}

let test_merge_non_objects: fn() -> void = fn() -> void {
    // Arrange
    let val1: Json = JNumber(1.0)
    let val2: Json = JNumber(2.0)

    // Act
    let result: Json = merge(val1, val2)

    // Assert
    match as_number(result) {
        Some(n) => { assert_f64_eq(n, 2.0, "merge non-objects should return second value") }
        None => { assert(false, "result should be number") }
    }
    return
}

let test_map_array_transform: fn() -> void = fn() -> void {
    // Arrange
    let arr: Json = JArray(Cons(
        JNumber(1.0),
        Cons(JNumber(2.0), Nil)
    ))

    // Act - double each number
    let result: Json = map_array(arr, fn(elem: Json) -> Json {
        match as_number(elem) {
            Some(n) => { return JNumber(n * 2.0) }
            None => { return elem }
        }
    })

    // Assert
    match get_index(result, 0) {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 2.0, "first element should be doubled") }
                None => { assert(false, "element should be number") }
            }
        }
        None => { assert(false, "should have element at index 0") }
    }
    return
}

let test_filter_array_predicate: fn() -> void = fn() -> void {
    // Arrange
    let arr: Json = JArray(Cons(
        JNumber(1.0),
        Cons(JNumber(2.0), Cons(JNumber(3.0), Nil))
    ))

    // Act - keep only numbers > 1
    let result: Json = filter_array(arr, fn(elem: Json) -> bool {
        match as_number(elem) {
            Some(n) => { return n > 1.0 }
            None => { return false }
        }
    })

    // Assert
    match size(result) {
        Some(n) => { assert_i32_eq(n, 2, "filtered array should have 2 elements") }
        None => { assert(false, "result should be array") }
    }
    return
}

let test_filter_fields_predicate: fn() -> void = fn() -> void {
    // Arrange
    let field1: JsonField = JsonField { key: "keep", value: JNumber(1.0) }
    let field2: JsonField = JsonField { key: "remove", value: JNumber(2.0) }
    let obj: Json = JObject(Cons(field1, Cons(field2, Nil)))

    // Act - keep only fields starting with "keep"
    let result: Json = filter_fields(obj, fn(key: string, value: Json) -> bool {
        return std.string.starts_with(key, "keep")
    })

    // Assert
    assert_some[Json](get_field(result, "keep"), "should keep 'keep' field")
    assert_none[Json](get_field(result, "remove"), "should remove 'remove' field")
    return
}

let test_make_field_helper: fn() -> void = fn() -> void {
    // Act
    let field: JsonField = make_field("test", JNull)

    // Assert
    assert_str_eq(field.key, "test", "make_field should set key")
    assert_true(is_null(field.value), "make_field should set value")
    return
}

// =============================================================================
// Round-Trip Tests (Property-Based)
// =============================================================================

let test_roundtrip_null: fn() -> void = fn() -> void {
    // Property: parse(stringify(x)) == x for null
    let original: Json = JNull
    let json_str: string = stringify(original)
    let parsed: Result[Json, JsonError] = parse(json_str)
    match parsed {
        Ok(v) => { assert_true(is_null(v), "roundtrip null should preserve null") }
        Err(_) => { assert(false, "roundtrip should succeed") }
    }
    return
}

let test_roundtrip_bool: fn() -> void = fn() -> void {
    let original: Json = JBool(true)
    let json_str: string = stringify(original)
    let parsed: Result[Json, JsonError] = parse(json_str)
    match parsed {
        Ok(v) => {
            match as_bool(v) {
                Some(b) => { assert_true(b, "roundtrip should preserve true") }
                None => { assert(false, "should be bool") }
            }
        }
        Err(_) => { assert(false, "roundtrip should succeed") }
    }
    return
}

let test_roundtrip_number: fn() -> void = fn() -> void {
    let original: Json = JNumber(42.5)
    let json_str: string = stringify(original)
    let parsed: Result[Json, JsonError] = parse(json_str)
    match parsed {
        Ok(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 42.5, "roundtrip should preserve number") }
                None => { assert(false, "should be number") }
            }
        }
        Err(_) => { assert(false, "roundtrip should succeed") }
    }
    return
}

let test_roundtrip_string: fn() -> void = fn() -> void {
    let original: Json = JString("hello world")
    let json_str: string = stringify(original)
    let parsed: Result[Json, JsonError] = parse(json_str)
    match parsed {
        Ok(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "hello world", "roundtrip should preserve string") }
                None => { assert(false, "should be string") }
            }
        }
        Err(_) => { assert(false, "roundtrip should succeed") }
    }
    return
}

let test_roundtrip_array: fn() -> void = fn() -> void {
    let original: Json = JArray(Cons(
        JNumber(1.0),
        Cons(JNumber(2.0), Nil)
    ))
    let json_str: string = stringify(original)
    let parsed: Result[Json, JsonError] = parse(json_str)
    match parsed {
        Ok(v) => {
            assert_true(is_array(v), "roundtrip should preserve array type")
            match size(v) {
                Some(n) => { assert_i32_eq(n, 2, "roundtrip should preserve array size") }
                None => { assert(false, "should be array") }
            }
        }
        Err(_) => { assert(false, "roundtrip should succeed") }
    }
    return
}

let test_roundtrip_object: fn() -> void = fn() -> void {
    let field: JsonField = JsonField { key: "name", value: JString("Alice") }
    let original: Json = JObject(Cons(field, Nil))
    let json_str: string = stringify(original)
    let parsed: Result[Json, JsonError] = parse(json_str)
    match parsed {
        Ok(v) => {
            assert_true(is_object(v), "roundtrip should preserve object type")
            match get_field(v, "name") {
                Some(val) => {
                    match as_string(val) {
                        Some(s) => { assert_str_eq(s, "Alice", "roundtrip should preserve field value") }
                        None => { assert(false, "name should be string") }
                    }
                }
                None => { assert(false, "should have name field") }
            }
        }
        Err(_) => { assert(false, "roundtrip should succeed") }
    }
    return
}

// =============================================================================
// Equality Tests
// =============================================================================

let test_equals_null_null: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JNull
    let b: Json = JNull

    // Act & Assert
    assert_true(equals(a, b), "null should equal null")
    return
}

let test_equals_null_non_null: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JNull
    let b: Json = JBool(false)

    // Act & Assert
    assert_true(not equals(a, b), "null should not equal false")
    return
}

let test_equals_bool_same: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JBool(true)
    let b: Json = JBool(true)

    // Act & Assert
    assert_true(equals(a, b), "true should equal true")
    return
}

let test_equals_bool_different: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JBool(true)
    let b: Json = JBool(false)

    // Act & Assert
    assert_true(not equals(a, b), "true should not equal false")
    return
}

let test_equals_number_same: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JNumber(42.0)
    let b: Json = JNumber(42.0)

    // Act & Assert
    assert_true(equals(a, b), "42.0 should equal 42.0")
    return
}

let test_equals_number_different: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JNumber(42.0)
    let b: Json = JNumber(43.0)

    // Act & Assert
    assert_true(not equals(a, b), "42.0 should not equal 43.0")
    return
}

let test_equals_number_precision: fn() -> void = fn() -> void {
    // Numbers that differ only by floating point precision should be equal
    // For example, 0.1 + 0.2 is not exactly 0.3 in IEEE 754
    let a: Json = JNumber(0.30000000000000004)
    let b: Json = JNumber(0.3)

    // Act & Assert
    assert_true(equals(a, b), "0.30000000000000004 should equal 0.3 (precision tolerance)")
    return
}

let test_equals_number_zero: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JNumber(0.0)
    let b: Json = JNumber(0.0)

    // Act & Assert
    assert_true(equals(a, b), "0.0 should equal 0.0")
    return
}

let test_equals_string_same: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JString("hello")
    let b: Json = JString("hello")

    // Act & Assert
    assert_true(equals(a, b), "\"hello\" should equal \"hello\"")
    return
}

let test_equals_string_different: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JString("hello")
    let b: Json = JString("world")

    // Act & Assert
    assert_true(not equals(a, b), "\"hello\" should not equal \"world\"")
    return
}

let test_equals_string_empty: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JString("")
    let b: Json = JString("")

    // Act & Assert
    assert_true(equals(a, b), "empty strings should be equal")
    return
}

let test_equals_array_same: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JArray(Cons(JNumber(1.0), Cons(JNumber(2.0), Nil)))
    let b: Json = JArray(Cons(JNumber(1.0), Cons(JNumber(2.0), Nil)))

    // Act & Assert
    assert_true(equals(a, b), "[1, 2] should equal [1, 2]")
    return
}

let test_equals_array_different_order: fn() -> void = fn() -> void {
    // Arrange - arrays ARE order-dependent
    let a: Json = JArray(Cons(JNumber(1.0), Cons(JNumber(2.0), Nil)))
    let b: Json = JArray(Cons(JNumber(2.0), Cons(JNumber(1.0), Nil)))

    // Act & Assert
    assert_true(not equals(a, b), "[1, 2] should not equal [2, 1] (order matters)")
    return
}

let test_equals_array_different_length: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JArray(Cons(JNumber(1.0), Nil))
    let b: Json = JArray(Cons(JNumber(1.0), Cons(JNumber(2.0), Nil)))

    // Act & Assert
    assert_true(not equals(a, b), "[1] should not equal [1, 2]")
    return
}

let test_equals_array_empty: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JArray(Nil)
    let b: Json = JArray(Nil)

    // Act & Assert
    assert_true(equals(a, b), "[] should equal []")
    return
}

let test_equals_object_same: fn() -> void = fn() -> void {
    // Arrange
    let field_a: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let a: Json = JObject(Cons(field_a, Nil))
    let field_b: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let b: Json = JObject(Cons(field_b, Nil))

    // Act & Assert
    assert_true(equals(a, b), "{\"x\": 1} should equal {\"x\": 1}")
    return
}

let test_equals_object_different_value: fn() -> void = fn() -> void {
    // Arrange
    let field_a: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let a: Json = JObject(Cons(field_a, Nil))
    let field_b: JsonField = JsonField { key: "x", value: JNumber(2.0) }
    let b: Json = JObject(Cons(field_b, Nil))

    // Act & Assert
    assert_true(not equals(a, b), "{\"x\": 1} should not equal {\"x\": 2}")
    return
}

let test_equals_object_different_key: fn() -> void = fn() -> void {
    // Arrange
    let field_a: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let a: Json = JObject(Cons(field_a, Nil))
    let field_b: JsonField = JsonField { key: "y", value: JNumber(1.0) }
    let b: Json = JObject(Cons(field_b, Nil))

    // Act & Assert
    assert_true(not equals(a, b), "{\"x\": 1} should not equal {\"y\": 1}")
    return
}

let test_equals_object_key_order_independent: fn() -> void = fn() -> void {
    // Arrange - same keys/values, different order in list
    let field_a1: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let field_a2: JsonField = JsonField { key: "y", value: JNumber(2.0) }
    let a: Json = JObject(Cons(field_a1, Cons(field_a2, Nil)))

    let field_b1: JsonField = JsonField { key: "y", value: JNumber(2.0) }
    let field_b2: JsonField = JsonField { key: "x", value: JNumber(1.0) }
    let b: Json = JObject(Cons(field_b1, Cons(field_b2, Nil)))

    // Act & Assert
    assert_true(equals(a, b), "{\"x\": 1, \"y\": 2} should equal {\"y\": 2, \"x\": 1}")
    return
}

let test_equals_object_empty: fn() -> void = fn() -> void {
    // Arrange
    let a: Json = JObject(Nil)
    let b: Json = JObject(Nil)

    // Act & Assert
    assert_true(equals(a, b), "{} should equal {}")
    return
}

let test_equals_nested_objects: fn() -> void = fn() -> void {
    // Arrange
    let inner_field: JsonField = JsonField { key: "inner", value: JNumber(42.0) }
    let inner: Json = JObject(Cons(inner_field, Nil))
    let outer_field: JsonField = JsonField { key: "outer", value: inner }

    let a: Json = JObject(Cons(outer_field, Nil))

    let inner_field2: JsonField = JsonField { key: "inner", value: JNumber(42.0) }
    let inner2: Json = JObject(Cons(inner_field2, Nil))
    let outer_field2: JsonField = JsonField { key: "outer", value: inner2 }

    let b: Json = JObject(Cons(outer_field2, Nil))

    // Act & Assert
    assert_true(equals(a, b), "nested objects should be deeply compared")
    return
}

let test_equals_nested_arrays: fn() -> void = fn() -> void {
    // Arrange
    let inner_a: Json = JArray(Cons(JNumber(1.0), Nil))
    let a: Json = JArray(Cons(inner_a, Nil))

    let inner_b: Json = JArray(Cons(JNumber(1.0), Nil))
    let b: Json = JArray(Cons(inner_b, Nil))

    // Act & Assert
    assert_true(equals(a, b), "[[1]] should equal [[1]]")
    return
}

let test_equals_mixed_nested: fn() -> void = fn() -> void {
    // Arrange - object containing array containing objects
    let inner_field: JsonField = JsonField { key: "v", value: JNumber(1.0) }
    let inner_obj: Json = JObject(Cons(inner_field, Nil))
    let arr: Json = JArray(Cons(inner_obj, Nil))
    let outer_field: JsonField = JsonField { key: "items", value: arr }
    let a: Json = JObject(Cons(outer_field, Nil))

    let inner_field2: JsonField = JsonField { key: "v", value: JNumber(1.0) }
    let inner_obj2: Json = JObject(Cons(inner_field2, Nil))
    let arr2: Json = JArray(Cons(inner_obj2, Nil))
    let outer_field2: JsonField = JsonField { key: "items", value: arr2 }
    let b: Json = JObject(Cons(outer_field2, Nil))

    // Act & Assert
    assert_true(equals(a, b), "deeply nested mixed structures should be compared correctly")
    return
}

let test_equals_different_types: fn() -> void = fn() -> void {
    // Arrange
    let num: Json = JNumber(1.0)
    let str: Json = JString("1")
    let arr: Json = JArray(Nil)
    let obj: Json = JObject(Nil)

    // Act & Assert
    assert_true(not equals(num, str), "number should not equal string")
    assert_true(not equals(arr, obj), "array should not equal object")
    assert_true(not equals(num, JNull), "number should not equal null")
    return
}

let test_equals_roundtrip: fn() -> void = fn() -> void {
    // Property: parse(stringify(x)) equals x
    let field1: JsonField = JsonField { key: "name", value: JString("Alice") }
    let field2: JsonField = JsonField { key: "age", value: JNumber(30.0) }
    let original: Json = JObject(Cons(field1, Cons(field2, Nil)))

    let json_str: string = stringify(original)
    let parsed: Result[Json, JsonError] = parse(json_str)

    match parsed {
        Ok(v) => { assert_true(equals(original, v), "parse(stringify(x)) should equal x") }
        Err(_) => { assert(false, "parse should succeed") }
    }
    return
}

// =============================================================================
// Structured Error Type Tests
// =============================================================================

let test_error_pattern_match_unterminated_string: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("\"hello")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            match e {
                UnterminatedString { line: _, col: _ } => {
                    // Expected error type
                    return
                }
                _ => { assert(false, "expected UnterminatedString error") }
            }
        }
    }
    return
}

let test_error_pattern_match_trailing_content: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("true false")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            match e {
                TrailingContent { found: _, line: _, col: _ } => {
                    // Expected error type
                    return
                }
                _ => { assert(false, "expected TrailingContent error") }
            }
        }
    }
    return
}

let test_error_pattern_match_invalid_number: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("007")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            match e {
                InvalidNumber { value: _, reason: _, line: _, col: _ } => {
                    // Expected error type
                    return
                }
                _ => { assert(false, "expected InvalidNumber error") }
            }
        }
    }
    return
}

let test_error_pattern_match_control_char: fn() -> void = fn() -> void {
    let input: string = "\"hello\tworld\""
    let result: Result[Json, JsonError] = parse(input)
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            match e {
                ControlChar { code: _, line: _, col: _ } => {
                    // Expected error type
                    return
                }
                _ => { assert(false, "expected ControlChar error") }
            }
        }
    }
    return
}

let test_error_pattern_match_invalid_escape: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("\"hello\\xworld\"")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            match e {
                InvalidEscape { sequence: _, reason: _, line: _, col: _ } => {
                    // Expected error type
                    return
                }
                _ => { assert(false, "expected InvalidEscape error") }
            }
        }
    }
    return
}

let test_error_pattern_match_unexpected_token: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("undefined")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            match e {
                UnexpectedToken { expected: _, found: _, line: _, col: _ } => {
                    // Expected error type
                    return
                }
                _ => { assert(false, "expected UnexpectedToken error") }
            }
        }
    }
    return
}

let test_error_pattern_match_unexpected_eof: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("[1, 2")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            match e {
                UnexpectedEof { expected: _, context: _, line: _, col: _ } => {
                    // Expected error type
                    return
                }
                _ => { assert(false, "expected UnexpectedEof error") }
            }
        }
    }
    return
}

let test_format_error_unterminated_string: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("\"hello")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            let msg: string = format_error(e)
            assert_true(std.string.contains(msg, "Unterminated"), "format_error should contain 'Unterminated'")
        }
    }
    return
}

let test_format_error_invalid_number: fn() -> void = fn() -> void {
    // Use a number with leading zeros which definitely triggers InvalidNumber
    let result: Result[Json, JsonError] = parse("007")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            let msg: string = format_error(e)
            assert_true(std.string.contains(msg, "Invalid number"), "format_error should contain 'Invalid number'")
        }
    }
    return
}

let test_error_line_helper: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("{\n  \"key\": undefined\n}")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            let line: i32 = error_line(e)
            assert_i32_eq(line, 2, "error_line should return line 2")
        }
    }
    return
}

let test_error_column_helper: fn() -> void = fn() -> void {
    let result: Result[Json, JsonError] = parse("  undefined")
    match result {
        Ok(_) => { assert(false, "parse should fail") }
        Err(e) => {
            let col: i32 = error_column(e)
            assert_i32_eq(col, 3, "error_column should return column 3")
        }
    }
    return
}

// =============================================================================
// Path-Based Access Tests
// =============================================================================

let test_get_path_simple_key: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JObject(Cons(JsonField { key: "name", value: JString("Alice") }, Nil))

    // Act
    let result: Option[Json] = get_path(json, "name")

    // Assert
    match result {
        Some(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "Alice", "get_path should return 'Alice'") }
                None => { assert(false, "get_path should return string") }
            }
        }
        None => { assert(false, "get_path should find 'name'") }
    }
    return
}

let test_get_path_nested_keys: fn() -> void = fn() -> void {
    // Arrange: {"user": {"address": {"city": "NYC"}}}
    let city: Json = JObject(Cons(JsonField { key: "city", value: JString("NYC") }, Nil))
    let address: Json = JObject(Cons(JsonField { key: "address", value: city }, Nil))
    let user: Json = JObject(Cons(JsonField { key: "user", value: address }, Nil))

    // Act
    let result: Option[Json] = get_path(user, "user.address.city")

    // Assert
    match result {
        Some(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "NYC", "get_path should return 'NYC'") }
                None => { assert(false, "get_path should return string") }
            }
        }
        None => { assert(false, "get_path should find nested path") }
    }
    return
}

let test_get_path_array_index: fn() -> void = fn() -> void {
    // Arrange: {"items": [1, 2, 3]}
    let arr: List[Json] = Cons(JNumber(1.0), Cons(JNumber(2.0), Cons(JNumber(3.0), Nil)))
    let json: Json = JObject(Cons(JsonField { key: "items", value: JArray(arr) }, Nil))

    // Act
    let result: Option[Json] = get_path(json, "items[1]")

    // Assert
    match result {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 2.0, "get_path should return 2.0") }
                None => { assert(false, "get_path should return number") }
            }
        }
        None => { assert(false, "get_path should find array element") }
    }
    return
}

let test_get_path_mixed_access: fn() -> void = fn() -> void {
    // Arrange: {"users": [{"name": "Alice"}, {"name": "Bob"}]}
    let user1: Json = JObject(Cons(JsonField { key: "name", value: JString("Alice") }, Nil))
    let user2: Json = JObject(Cons(JsonField { key: "name", value: JString("Bob") }, Nil))
    let users: Json = JArray(Cons(user1, Cons(user2, Nil)))
    let json: Json = JObject(Cons(JsonField { key: "users", value: users }, Nil))

    // Act
    let result: Option[Json] = get_path(json, "users[1].name")

    // Assert
    match result {
        Some(v) => {
            match as_string(v) {
                Some(s) => { assert_str_eq(s, "Bob", "get_path should return 'Bob'") }
                None => { assert(false, "get_path should return string") }
            }
        }
        None => { assert(false, "get_path should find users[1].name") }
    }
    return
}

let test_get_path_empty_path: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JNumber(42.0)

    // Act
    let result: Option[Json] = get_path(json, "")

    // Assert
    match result {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 42.0, "empty path should return original value") }
                None => { assert(false, "should return number") }
            }
        }
        None => { assert(false, "empty path should succeed") }
    }
    return
}

let test_get_path_nonexistent_key: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JObject(Cons(JsonField { key: "a", value: JNumber(1.0) }, Nil))

    // Act
    let result: Option[Json] = get_path(json, "b")

    // Assert
    assert_none[Json](result, "get_path should return None for nonexistent key")
    return
}

let test_get_path_out_of_bounds_index: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JArray(Cons(JNumber(1.0), Nil))

    // Act
    let result: Option[Json] = get_path(json, "[5]")

    // Assert
    assert_none[Json](result, "get_path should return None for out-of-bounds index")
    return
}

let test_get_path_type_mismatch: fn() -> void = fn() -> void {
    // Arrange: try to use key access on array
    let json: Json = JArray(Cons(JNumber(1.0), Nil))

    // Act
    let result: Option[Json] = get_path(json, "key")

    // Assert
    assert_none[Json](result, "get_path should return None for type mismatch")
    return
}

let test_set_path_simple_key: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JObject(Cons(JsonField { key: "x", value: JNumber(1.0) }, Nil))

    // Act
    let result: Json = set_path(json, "y", JNumber(2.0))

    // Assert
    match get_path(result, "y") {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 2.0, "set_path should set new key") }
                None => { assert(false, "should be number") }
            }
        }
        None => { assert(false, "set_path should create key") }
    }
    return
}

let test_set_path_nested_keys: fn() -> void = fn() -> void {
    // Arrange: start with empty object
    let json: Json = JObject(Nil)

    // Act
    let result: Json = set_path(json, "a.b.c", JNumber(42.0))

    // Assert
    match get_path(result, "a.b.c") {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 42.0, "set_path should create nested path") }
                None => { assert(false, "should be number") }
            }
        }
        None => { assert(false, "set_path should create nested structure") }
    }
    return
}

let test_set_path_array_index: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JArray(Cons(JNumber(1.0), Cons(JNumber(2.0), Nil)))

    // Act
    let result: Json = set_path(json, "[1]", JNumber(99.0))

    // Assert
    match get_path(result, "[1]") {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 99.0, "set_path should update array element") }
                None => { assert(false, "should be number") }
            }
        }
        None => { assert(false, "set_path should keep array element") }
    }
    return
}

let test_set_path_extend_array: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JArray(Nil)

    // Act
    let result: Json = set_path(json, "[2]", JNumber(42.0))

    // Assert - array should have [null, null, 42]
    match get_path(result, "[2]") {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 42.0, "set_path should extend array") }
                None => { assert(false, "should be number") }
            }
        }
        None => { assert(false, "set_path should create index") }
    }
    match get_path(result, "[0]") {
        Some(v) => { assert_true(is_null(v), "index 0 should be null") }
        None => { assert(false, "index 0 should exist") }
    }
    return
}

let test_set_path_empty_path: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JNumber(1.0)

    // Act
    let result: Json = set_path(json, "", JNumber(42.0))

    // Assert
    match as_number(result) {
        Some(n) => { assert_f64_eq(n, 42.0, "empty path should replace value") }
        None => { assert(false, "should be number") }
    }
    return
}

let test_has_path_exists: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JObject(Cons(JsonField { key: "x", value: JNumber(1.0) }, Nil))

    // Act
    let result: bool = has_path(json, "x")

    // Assert
    assert_true(result, "has_path should return true for existing path")
    return
}

let test_has_path_not_exists: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JObject(Cons(JsonField { key: "x", value: JNumber(1.0) }, Nil))

    // Act
    let result: bool = has_path(json, "y")

    // Assert
    assert_true(not result, "has_path should return false for nonexistent path")
    return
}

let test_remove_path_simple_key: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JObject(Cons(
        JsonField { key: "a", value: JNumber(1.0) },
        Cons(JsonField { key: "b", value: JNumber(2.0) }, Nil)
    ))

    // Act
    let result: Json = remove_path(json, "a")

    // Assert
    assert_true(not has_path(result, "a"), "remove_path should remove key 'a'")
    assert_true(has_path(result, "b"), "remove_path should keep key 'b'")
    return
}

let test_remove_path_nested: fn() -> void = fn() -> void {
    // Arrange: {"outer": {"inner": 1, "other": 2}}
    let inner_obj: Json = JObject(Cons(
        JsonField { key: "inner", value: JNumber(1.0) },
        Cons(JsonField { key: "other", value: JNumber(2.0) }, Nil)
    ))
    let json: Json = JObject(Cons(JsonField { key: "outer", value: inner_obj }, Nil))

    // Act
    let result: Json = remove_path(json, "outer.inner")

    // Assert
    assert_true(not has_path(result, "outer.inner"), "remove_path should remove nested key")
    assert_true(has_path(result, "outer.other"), "remove_path should keep sibling")
    return
}

let test_remove_path_array_index: fn() -> void = fn() -> void {
    // Arrange
    let json: Json = JArray(Cons(JNumber(1.0), Cons(JNumber(2.0), Cons(JNumber(3.0), Nil))))

    // Act
    let result: Json = remove_path(json, "[1]")

    // Assert
    match size(result) {
        Some(s) => { assert_i32_eq(s, 2, "array should have 2 elements after remove") }
        None => { assert(false, "should be array") }
    }
    match get_path(result, "[1]") {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 3.0, "index 1 should now be 3.0") }
                None => { assert(false, "should be number") }
            }
        }
        None => { assert(false, "index 1 should exist") }
    }
    return
}

let test_get_path_consecutive_array_indices: fn() -> void = fn() -> void {
    // Arrange: [[1, 2], [3, 4]]
    let inner1: Json = JArray(Cons(JNumber(1.0), Cons(JNumber(2.0), Nil)))
    let inner2: Json = JArray(Cons(JNumber(3.0), Cons(JNumber(4.0), Nil)))
    let json: Json = JArray(Cons(inner1, Cons(inner2, Nil)))

    // Act
    let result: Option[Json] = get_path(json, "[1][0]")

    // Assert
    match result {
        Some(v) => {
            match as_number(v) {
                Some(n) => { assert_f64_eq(n, 3.0, "get_path should handle consecutive indices") }
                None => { assert(false, "should be number") }
            }
        }
        None => { assert(false, "get_path should find [1][0]") }
    }
    return
}

// =============================================================================
// Stack Safety Tests
// =============================================================================

let test_default_max_depth_returns_512: fn() -> void = fn() -> void {
    // Arrange & Act
    let depth: i32 = default_max_depth()

    // Assert
    assert_i32_eq(depth, 512, "default_max_depth should return 512")
    return
}

let test_parse_with_max_depth_small_limit_success: fn() -> void = fn() -> void {
    // Arrange: simple array with depth 2 (outer array + inner value)
    let input: string = "[1, 2, 3]"

    // Act
    let result: Result[Json, JsonError] = parse_with_max_depth(input, 5)

    // Assert
    assert_ok[Json, JsonError](result, "should parse successfully within depth limit")
    return
}

let test_parse_with_max_depth_nested_array_exceeds_limit: fn() -> void = fn() -> void {
    // Arrange: nested arrays with depth 4: [[[1]]]
    let input: string = "[[[1]]]"

    // Act
    let result: Result[Json, JsonError] = parse_with_max_depth(input, 2)

    // Assert
    match result {
        Ok(_) => { assert(false, "should fail when depth exceeds limit") }
        Err(MaxDepthExceeded { depth: d, max_depth: m, line: _, col: _ }) => {
            assert_i32_eq(m, 2, "max_depth should be 2")
            assert_i32_eq(d, 3, "depth should be 3 when failure occurs")
        }
        Err(_) => { assert(false, "should be MaxDepthExceeded error") }
    }
    return
}

let test_parse_with_max_depth_nested_object_exceeds_limit: fn() -> void = fn() -> void {
    // Arrange: nested objects with depth 3: {"a": {"b": 1}}
    let input: string = "{\"a\": {\"b\": 1}}"

    // Act
    let result: Result[Json, JsonError] = parse_with_max_depth(input, 1)

    // Assert
    match result {
        Ok(_) => { assert(false, "should fail when depth exceeds limit") }
        Err(MaxDepthExceeded { depth: _, max_depth: m, line: _, col: _ }) => {
            assert_i32_eq(m, 1, "max_depth should be 1")
        }
        Err(_) => { assert(false, "should be MaxDepthExceeded error") }
    }
    return
}

let test_parse_with_max_depth_at_exact_limit: fn() -> void = fn() -> void {
    // Arrange: depth 2 with limit 2
    let input: string = "[[1]]"

    // Act
    let result: Result[Json, JsonError] = parse_with_max_depth(input, 2)

    // Assert
    assert_ok[Json, JsonError](result, "should parse at exact depth limit")
    return
}

let test_parse_with_max_depth_zero_means_unlimited: fn() -> void = fn() -> void {
    // Arrange: depth 3 with limit 0 (unlimited)
    let input: string = "[[[1]]]"

    // Act
    let result: Result[Json, JsonError] = parse_with_max_depth(input, 0)

    // Assert
    assert_ok[Json, JsonError](result, "limit 0 should mean unlimited depth")
    return
}

let test_parse_default_allows_nested_structures: fn() -> void = fn() -> void {
    // Arrange: moderately nested structure (depth 3)
    let input: string = "{\"a\": {\"b\": [1, 2, 3]}}"

    // Act
    let result: Result[Json, JsonError] = parse(input)

    // Assert
    assert_ok[Json, JsonError](result, "default parse should allow reasonable nesting")
    return
}

let test_format_error_max_depth_exceeded: fn() -> void = fn() -> void {
    // Arrange
    let err: JsonError = MaxDepthExceeded { depth: 10, max_depth: 5, line: 1, col: 15 }

    // Act
    let msg: string = format_error(err)

    // Assert
    assert_true(std.string.length(msg) > 0, "format_error should produce non-empty message for MaxDepthExceeded")
    return
}

let test_error_line_max_depth_exceeded: fn() -> void = fn() -> void {
    // Arrange
    let err: JsonError = MaxDepthExceeded { depth: 10, max_depth: 5, line: 3, col: 7 }

    // Act
    let line: i32 = error_line(err)

    // Assert
    assert_i32_eq(line, 3, "error_line should return line from MaxDepthExceeded")
    return
}

let test_error_column_max_depth_exceeded: fn() -> void = fn() -> void {
    // Arrange
    let err: JsonError = MaxDepthExceeded { depth: 10, max_depth: 5, line: 3, col: 7 }

    // Act
    let col: i32 = error_column(err)

    // Assert
    assert_i32_eq(col, 7, "error_column should return column from MaxDepthExceeded")
    return
}

// =============================================================================
// Duplicate Key Handling Tests
// =============================================================================

let test_parse_duplicate_keys_first_wins: fn() -> void = fn() -> void {
    // Arrange - regular parse uses first-wins behavior (get_field returns first match)
    let input: string = "{\"a\": 1, \"a\": 2}"

    // Act
    let result: Result[Json, JsonError] = parse(input)

    // Assert
    match result {
        Ok(json) => {
            match get_field(json, "a") {
                Some(val) => {
                    match as_number(val) {
                        Some(n) => { assert_f64_eq(n, 1.0, "get_field returns first occurrence (first-wins)") }
                        None => { assert(false, "expected number value") }
                    }
                }
                None => { assert(false, "expected field 'a' to exist") }
            }
        }
        Err(e) => { assert(false, "parse should succeed with duplicate keys") }
    }
    return
}

let test_parse_strict_rejects_duplicate_keys: fn() -> void = fn() -> void {
    // Arrange
    let input: string = "{\"a\": 1, \"a\": 2}"

    // Act
    let result: Result[Json, JsonError] = parse_strict(input)

    // Assert
    match result {
        Ok(_) => { assert(false, "parse_strict should reject duplicate keys") }
        Err(e) => {
            match e {
                DuplicateKey { key: k, line: _, col: _ } => {
                    assert(std.string.equals(k, "a"), "error should contain duplicate key name")
                }
                _ => { assert(false, "expected DuplicateKey error") }
            }
        }
    }
    return
}

let test_parse_strict_error_position: fn() -> void = fn() -> void {
    // Arrange - second "a" is at column 10 (after '{"a": 1, ')
    let input: string = "{\"a\": 1, \"a\": 2}"

    // Act
    let result: Result[Json, JsonError] = parse_strict(input)

    // Assert
    match result {
        Err(DuplicateKey { key: k, line: l, col: c }) => {
            assert(std.string.equals(k, "a"), "error should contain key name")
            assert_i32_eq(l, 1, "error should be on line 1")
            assert_i32_eq(c, 10, "error should be at column 10")
        }
        _ => { assert(false, "expected DuplicateKey error with position") }
    }
    return
}

let test_parse_strict_nested_object_duplicates: fn() -> void = fn() -> void {
    // Arrange - nested object with duplicate keys
    let input: string = "{\"outer\": {\"inner\": 1, \"inner\": 2}}"

    // Act
    let result: Result[Json, JsonError] = parse_strict(input)

    // Assert
    match result {
        Ok(_) => { assert(false, "parse_strict should reject nested duplicate keys") }
        Err(DuplicateKey { key: k, line: _, col: _ }) => {
            assert(std.string.equals(k, "inner"), "error should contain nested duplicate key name")
        }
        _ => { assert(false, "expected DuplicateKey error") }
    }
    return
}

let test_parse_strict_accepts_unique_keys: fn() -> void = fn() -> void {
    // Arrange - all keys are unique
    let input: string = "{\"a\": 1, \"b\": 2, \"c\": 3}"

    // Act
    let result: Result[Json, JsonError] = parse_strict(input)

    // Assert
    match result {
        Ok(json) => {
            assert(is_object(json), "result should be an object")
            match size(json) {
                Some(s) => { assert_i32_eq(s, 3, "object should have 3 fields") }
                None => { assert(false, "size should return Some for object") }
            }
        }
        Err(_) => { assert(false, "parse_strict should accept unique keys") }
    }
    return
}

let test_parse_strict_with_max_depth: fn() -> void = fn() -> void {
    // Arrange
    let input: string = "{\"a\": 1, \"a\": 2}"

    // Act
    let result: Result[Json, JsonError] = parse_strict_with_max_depth(input, 10)

    // Assert
    match result {
        Ok(_) => { assert(false, "parse_strict_with_max_depth should reject duplicate keys") }
        Err(DuplicateKey { key: _, line: _, col: _ }) => {
            assert(true, "got expected DuplicateKey error")
        }
        _ => { assert(false, "expected DuplicateKey error") }
    }
    return
}

let test_format_error_duplicate_key: fn() -> void = fn() -> void {
    // Arrange
    let err: JsonError = DuplicateKey { key: "foo", line: 2, col: 5 }

    // Act
    let msg: string = format_error(err)

    // Assert
    assert(std.string.contains(msg, "Duplicate key"), "message should mention duplicate key")
    assert(std.string.contains(msg, "foo"), "message should contain key name")
    assert(std.string.contains(msg, "line 2"), "message should contain line number")
    assert(std.string.contains(msg, "column 5"), "message should contain column number")
    return
}

let test_error_line_duplicate_key: fn() -> void = fn() -> void {
    // Arrange
    let err: JsonError = DuplicateKey { key: "bar", line: 5, col: 10 }

    // Act
    let line: i32 = error_line(err)

    // Assert
    assert_i32_eq(line, 5, "error_line should return line from DuplicateKey")
    return
}

let test_error_column_duplicate_key: fn() -> void = fn() -> void {
    // Arrange
    let err: JsonError = DuplicateKey { key: "bar", line: 5, col: 10 }

    // Act
    let col: i32 = error_column(err)

    // Assert
    assert_i32_eq(col, 10, "error_column should return column from DuplicateKey")
    return
}

let test_parse_strict_multiple_duplicates_first_reported: fn() -> void = fn() -> void {
    // Arrange - multiple duplicates, first duplicate should be reported
    let input: string = "{\"a\": 1, \"b\": 2, \"a\": 3, \"b\": 4}"

    // Act
    let result: Result[Json, JsonError] = parse_strict(input)

    // Assert
    match result {
        Err(DuplicateKey { key: k, line: _, col: _ }) => {
            assert(std.string.equals(k, "a"), "first duplicate key should be reported")
        }
        _ => { assert(false, "expected DuplicateKey error") }
    }
    return
}

// =============================================================================
// Test Runner
// =============================================================================

effect fn run_test(name: string, test_fn: fn() -> void) -> IO[void] {
    std.io.print("  ")
    std.io.print(name)
    std.io.print(" ... ")
    test_fn()
    std.io.println("ok")
    return
}

effect fn main() -> IO[void] {
    std.io.println("Running JSON Library Tests")
    std.io.println("==========================")
    std.io.println("")

    std.io.println("Type Checking Predicates:")
    run_test("test_is_null_with_null", test_is_null_with_null)
    run_test("test_is_null_with_non_null", test_is_null_with_non_null)
    run_test("test_is_bool_with_bool", test_is_bool_with_bool)
    run_test("test_is_bool_with_non_bool", test_is_bool_with_non_bool)
    run_test("test_is_number_with_number", test_is_number_with_number)
    run_test("test_is_number_with_non_number", test_is_number_with_non_number)
    run_test("test_is_string_with_string", test_is_string_with_string)
    run_test("test_is_string_with_empty_string", test_is_string_with_empty_string)
    run_test("test_is_array_with_array", test_is_array_with_array)
    run_test("test_is_array_with_empty_array", test_is_array_with_empty_array)
    run_test("test_is_object_with_object", test_is_object_with_object)
    run_test("test_is_object_with_empty_object", test_is_object_with_empty_object)
    std.io.println("")

    std.io.println("Type Names:")
    run_test("test_type_name_null", test_type_name_null)
    run_test("test_type_name_boolean", test_type_name_boolean)
    run_test("test_type_name_number", test_type_name_number)
    run_test("test_type_name_string", test_type_name_string)
    run_test("test_type_name_array", test_type_name_array)
    run_test("test_type_name_object", test_type_name_object)
    std.io.println("")

    std.io.println("Value Extractors:")
    run_test("test_as_string_with_string", test_as_string_with_string)
    run_test("test_as_string_with_non_string", test_as_string_with_non_string)
    run_test("test_as_number_with_number", test_as_number_with_number)
    run_test("test_as_number_with_non_number", test_as_number_with_non_number)
    run_test("test_as_int_with_integer", test_as_int_with_integer)
    run_test("test_as_int_truncates_decimal", test_as_int_truncates_decimal)
    run_test("test_as_bool_with_true", test_as_bool_with_true)
    run_test("test_as_bool_with_false", test_as_bool_with_false)
    run_test("test_as_array_with_array", test_as_array_with_array)
    run_test("test_as_object_with_object", test_as_object_with_object)
    std.io.println("")

    std.io.println("Field/Index Accessors:")
    run_test("test_get_field_existing", test_get_field_existing)
    run_test("test_get_field_non_existing", test_get_field_non_existing)
    run_test("test_get_field_on_non_object", test_get_field_on_non_object)
    run_test("test_get_index_valid", test_get_index_valid)
    run_test("test_get_index_out_of_bounds", test_get_index_out_of_bounds)
    run_test("test_get_index_negative", test_get_index_negative)
    run_test("test_size_array", test_size_array)
    run_test("test_size_empty_array", test_size_empty_array)
    run_test("test_size_object", test_size_object)
    run_test("test_size_non_container", test_size_non_container)
    run_test("test_keys_object", test_keys_object)
    run_test("test_keys_non_object", test_keys_non_object)
    run_test("test_values_object", test_values_object)
    std.io.println("")

    std.io.println("Serialization:")
    run_test("test_stringify_null", test_stringify_null)
    run_test("test_stringify_true", test_stringify_true)
    run_test("test_stringify_false", test_stringify_false)
    run_test("test_stringify_number_integer", test_stringify_number_integer)
    run_test("test_stringify_string_simple", test_stringify_string_simple)
    run_test("test_stringify_string_with_quotes", test_stringify_string_with_quotes)
    run_test("test_stringify_string_with_newline", test_stringify_string_with_newline)
    run_test("test_stringify_empty_array", test_stringify_empty_array)
    run_test("test_stringify_array_with_elements", test_stringify_array_with_elements)
    run_test("test_stringify_empty_object", test_stringify_empty_object)
    run_test("test_stringify_object_with_fields", test_stringify_object_with_fields)
    run_test("test_stringify_pretty_indentation", test_stringify_pretty_indentation)
    std.io.println("")

    std.io.println("Parsing:")
    run_test("test_parse_null", test_parse_null)
    run_test("test_parse_true", test_parse_true)
    run_test("test_parse_false", test_parse_false)
    run_test("test_parse_integer", test_parse_integer)
    run_test("test_parse_negative_number", test_parse_negative_number)
    run_test("test_parse_decimal", test_parse_decimal)
    run_test("test_parse_exponent", test_parse_exponent)
    run_test("test_parse_string_simple", test_parse_string_simple)
    run_test("test_parse_string_empty", test_parse_string_empty)
    run_test("test_parse_string_escaped_quote", test_parse_string_escaped_quote)
    run_test("test_parse_string_escaped_newline", test_parse_string_escaped_newline)
    run_test("test_parse_array_empty", test_parse_array_empty)
    run_test("test_parse_array_with_elements", test_parse_array_with_elements)
    run_test("test_parse_array_mixed_types", test_parse_array_mixed_types)
    run_test("test_parse_object_empty", test_parse_object_empty)
    run_test("test_parse_object_single_field", test_parse_object_single_field)
    run_test("test_parse_object_multiple_fields", test_parse_object_multiple_fields)
    run_test("test_parse_nested_object", test_parse_nested_object)
    run_test("test_parse_with_whitespace", test_parse_with_whitespace)
    std.io.println("")

    std.io.println("Parser Errors:")
    run_test("test_parse_error_invalid_token", test_parse_error_invalid_token)
    run_test("test_parse_error_unterminated_string", test_parse_error_unterminated_string)
    run_test("test_parse_error_unterminated_array", test_parse_error_unterminated_array)
    run_test("test_parse_error_unterminated_object", test_parse_error_unterminated_object)
    run_test("test_parse_error_trailing_content", test_parse_error_trailing_content)
    run_test("test_parse_error_missing_colon", test_parse_error_missing_colon)
    run_test("test_parse_error_position_tracking", test_parse_error_position_tracking)
    std.io.println("")

    std.io.println("Number Edge Cases:")
    run_test("test_parse_number_leading_zero_rejected", test_parse_number_leading_zero_rejected)
    run_test("test_parse_number_leading_zero_negative_rejected", test_parse_number_leading_zero_negative_rejected)
    run_test("test_parse_number_zero_alone_valid", test_parse_number_zero_alone_valid)
    run_test("test_parse_number_zero_decimal_valid", test_parse_number_zero_decimal_valid)
    run_test("test_parse_number_zero_exponent_valid", test_parse_number_zero_exponent_valid)
    run_test("test_parse_number_very_large_overflow", test_parse_number_very_large_overflow)
    run_test("test_parse_number_very_small_underflow", test_parse_number_very_small_underflow)
    run_test("test_parse_number_negative_very_large", test_parse_number_negative_very_large)
    run_test("test_parse_number_scientific_notation_valid", test_parse_number_scientific_notation_valid)
    run_test("test_parse_number_negative_exponent_valid", test_parse_number_negative_exponent_valid)
    std.io.println("")

    std.io.println("String Validation:")
    run_test("test_parse_string_with_escaped_tab_valid", test_parse_string_with_escaped_tab_valid)
    run_test("test_parse_string_with_escaped_backspace_valid", test_parse_string_with_escaped_backspace_valid)
    run_test("test_parse_string_with_escaped_formfeed_valid", test_parse_string_with_escaped_formfeed_valid)
    run_test("test_parse_string_with_escaped_carriage_return_valid", test_parse_string_with_escaped_carriage_return_valid)
    run_test("test_parse_string_with_unicode_escape_null_valid", test_parse_string_with_unicode_escape_null_valid)
    run_test("test_parse_string_with_unicode_escape_control_valid", test_parse_string_with_unicode_escape_control_valid)
    std.io.println("")

    std.io.println("UTF-16 Surrogate Pairs:")
    run_test("test_parse_surrogate_pair_emoji_grinning_face", test_parse_surrogate_pair_emoji_grinning_face)
    run_test("test_parse_surrogate_pair_pile_of_poo", test_parse_surrogate_pair_pile_of_poo)
    run_test("test_parse_surrogate_pair_in_context", test_parse_surrogate_pair_in_context)
    run_test("test_parse_lone_high_surrogate_replaced", test_parse_lone_high_surrogate_replaced)
    run_test("test_parse_lone_low_surrogate_replaced", test_parse_lone_low_surrogate_replaced)
    run_test("test_parse_high_surrogate_at_end_replaced", test_parse_high_surrogate_at_end_replaced)
    run_test("test_parse_high_surrogate_followed_by_non_surrogate", test_parse_high_surrogate_followed_by_non_surrogate)
    run_test("test_parse_multiple_surrogate_pairs", test_parse_multiple_surrogate_pairs)
    run_test("test_parse_surrogate_pair_musical_symbol", test_parse_surrogate_pair_musical_symbol)
    std.io.println("")

    std.io.println("Control Character Rejection:")
    run_test("test_parse_string_unescaped_tab_rejected", test_parse_string_unescaped_tab_rejected)
    run_test("test_parse_string_unescaped_newline_rejected", test_parse_string_unescaped_newline_rejected)
    run_test("test_parse_string_unescaped_carriage_return_rejected", test_parse_string_unescaped_carriage_return_rejected)
    run_test("test_parse_string_invalid_escape_rejected", test_parse_string_invalid_escape_rejected)
    run_test("test_parse_string_bare_backslash_rejected", test_parse_string_bare_backslash_rejected)
    std.io.println("")

    std.io.println("Transformers:")
    run_test("test_set_field_new", test_set_field_new)
    run_test("test_set_field_update", test_set_field_update)
    run_test("test_set_field_on_non_object", test_set_field_on_non_object)
    run_test("test_remove_field_existing", test_remove_field_existing)
    run_test("test_remove_field_non_existing", test_remove_field_non_existing)
    run_test("test_merge_objects", test_merge_objects)
    run_test("test_merge_override", test_merge_override)
    run_test("test_merge_non_objects", test_merge_non_objects)
    run_test("test_map_array_transform", test_map_array_transform)
    run_test("test_filter_array_predicate", test_filter_array_predicate)
    run_test("test_filter_fields_predicate", test_filter_fields_predicate)
    run_test("test_make_field_helper", test_make_field_helper)
    std.io.println("")

    std.io.println("Round-Trip (Property Tests):")
    run_test("test_roundtrip_null", test_roundtrip_null)
    run_test("test_roundtrip_bool", test_roundtrip_bool)
    run_test("test_roundtrip_number", test_roundtrip_number)
    run_test("test_roundtrip_string", test_roundtrip_string)
    run_test("test_roundtrip_array", test_roundtrip_array)
    run_test("test_roundtrip_object", test_roundtrip_object)
    std.io.println("")

    std.io.println("Equality:")
    run_test("test_equals_null_null", test_equals_null_null)
    run_test("test_equals_null_non_null", test_equals_null_non_null)
    run_test("test_equals_bool_same", test_equals_bool_same)
    run_test("test_equals_bool_different", test_equals_bool_different)
    run_test("test_equals_number_same", test_equals_number_same)
    run_test("test_equals_number_different", test_equals_number_different)
    run_test("test_equals_number_precision", test_equals_number_precision)
    run_test("test_equals_number_zero", test_equals_number_zero)
    run_test("test_equals_string_same", test_equals_string_same)
    run_test("test_equals_string_different", test_equals_string_different)
    run_test("test_equals_string_empty", test_equals_string_empty)
    run_test("test_equals_array_same", test_equals_array_same)
    run_test("test_equals_array_different_order", test_equals_array_different_order)
    run_test("test_equals_array_different_length", test_equals_array_different_length)
    run_test("test_equals_array_empty", test_equals_array_empty)
    run_test("test_equals_object_same", test_equals_object_same)
    run_test("test_equals_object_different_value", test_equals_object_different_value)
    run_test("test_equals_object_different_key", test_equals_object_different_key)
    run_test("test_equals_object_key_order_independent", test_equals_object_key_order_independent)
    run_test("test_equals_object_empty", test_equals_object_empty)
    run_test("test_equals_nested_objects", test_equals_nested_objects)
    run_test("test_equals_nested_arrays", test_equals_nested_arrays)
    run_test("test_equals_mixed_nested", test_equals_mixed_nested)
    run_test("test_equals_different_types", test_equals_different_types)
    run_test("test_equals_roundtrip", test_equals_roundtrip)
    std.io.println("")

    std.io.println("Structured Error Types:")
    run_test("test_error_pattern_match_unterminated_string", test_error_pattern_match_unterminated_string)
    run_test("test_error_pattern_match_trailing_content", test_error_pattern_match_trailing_content)
    run_test("test_error_pattern_match_invalid_number", test_error_pattern_match_invalid_number)
    run_test("test_error_pattern_match_control_char", test_error_pattern_match_control_char)
    run_test("test_error_pattern_match_invalid_escape", test_error_pattern_match_invalid_escape)
    run_test("test_error_pattern_match_unexpected_token", test_error_pattern_match_unexpected_token)
    run_test("test_error_pattern_match_unexpected_eof", test_error_pattern_match_unexpected_eof)
    run_test("test_format_error_unterminated_string", test_format_error_unterminated_string)
    run_test("test_format_error_invalid_number", test_format_error_invalid_number)
    run_test("test_error_line_helper", test_error_line_helper)
    run_test("test_error_column_helper", test_error_column_helper)
    std.io.println("")

    std.io.println("Path-Based Access:")
    run_test("test_get_path_simple_key", test_get_path_simple_key)
    run_test("test_get_path_nested_keys", test_get_path_nested_keys)
    run_test("test_get_path_array_index", test_get_path_array_index)
    run_test("test_get_path_mixed_access", test_get_path_mixed_access)
    run_test("test_get_path_empty_path", test_get_path_empty_path)
    run_test("test_get_path_nonexistent_key", test_get_path_nonexistent_key)
    run_test("test_get_path_out_of_bounds_index", test_get_path_out_of_bounds_index)
    run_test("test_get_path_type_mismatch", test_get_path_type_mismatch)
    run_test("test_get_path_consecutive_array_indices", test_get_path_consecutive_array_indices)
    run_test("test_set_path_simple_key", test_set_path_simple_key)
    run_test("test_set_path_nested_keys", test_set_path_nested_keys)
    run_test("test_set_path_array_index", test_set_path_array_index)
    run_test("test_set_path_extend_array", test_set_path_extend_array)
    run_test("test_set_path_empty_path", test_set_path_empty_path)
    run_test("test_has_path_exists", test_has_path_exists)
    run_test("test_has_path_not_exists", test_has_path_not_exists)
    run_test("test_remove_path_simple_key", test_remove_path_simple_key)
    run_test("test_remove_path_nested", test_remove_path_nested)
    run_test("test_remove_path_array_index", test_remove_path_array_index)
    std.io.println("")

    std.io.println("Stack Safety:")
    run_test("test_default_max_depth_returns_512", test_default_max_depth_returns_512)
    run_test("test_parse_with_max_depth_small_limit_success", test_parse_with_max_depth_small_limit_success)
    run_test("test_parse_with_max_depth_nested_array_exceeds_limit", test_parse_with_max_depth_nested_array_exceeds_limit)
    run_test("test_parse_with_max_depth_nested_object_exceeds_limit", test_parse_with_max_depth_nested_object_exceeds_limit)
    run_test("test_parse_with_max_depth_at_exact_limit", test_parse_with_max_depth_at_exact_limit)
    run_test("test_parse_with_max_depth_zero_means_unlimited", test_parse_with_max_depth_zero_means_unlimited)
    run_test("test_parse_default_allows_nested_structures", test_parse_default_allows_nested_structures)
    run_test("test_format_error_max_depth_exceeded", test_format_error_max_depth_exceeded)
    run_test("test_error_line_max_depth_exceeded", test_error_line_max_depth_exceeded)
    run_test("test_error_column_max_depth_exceeded", test_error_column_max_depth_exceeded)
    std.io.println("")

    std.io.println("Duplicate Key Handling:")
    run_test("test_parse_duplicate_keys_first_wins", test_parse_duplicate_keys_first_wins)
    run_test("test_parse_strict_rejects_duplicate_keys", test_parse_strict_rejects_duplicate_keys)
    run_test("test_parse_strict_error_position", test_parse_strict_error_position)
    run_test("test_parse_strict_nested_object_duplicates", test_parse_strict_nested_object_duplicates)
    run_test("test_parse_strict_accepts_unique_keys", test_parse_strict_accepts_unique_keys)
    run_test("test_parse_strict_with_max_depth", test_parse_strict_with_max_depth)
    run_test("test_format_error_duplicate_key", test_format_error_duplicate_key)
    run_test("test_error_line_duplicate_key", test_error_line_duplicate_key)
    run_test("test_error_column_duplicate_key", test_error_column_duplicate_key)
    run_test("test_parse_strict_multiple_duplicates_first_reported", test_parse_strict_multiple_duplicates_first_reported)
    std.io.println("")

    std.io.println("==========================")
    std.io.println("All tests passed!")
    return
}
