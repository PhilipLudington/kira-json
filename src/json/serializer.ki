/// JSON serialization functions.
/// Provides stringify and stringify_pretty for converting JSON values to strings.

module json.serializer

import src.json.types.{ Json, JNull, JBool, JNumber, JString, JArray, JObject, JsonField }

// =============================================================================
// String Escaping
// =============================================================================

/// Escapes a string for JSON output.
/// Uses std.string.chars for proper character iteration.
let escape_string: fn(string) -> string = fn(s: string) -> string {
    match std.string.chars(s) {
        Err(_) => {
            // On invalid UTF-8, return the string as-is (will be caught during parsing)
            return s
        }
        Ok(chars) => {
            let builder: StringBuilder = escape_chars_to_builder(chars, std.builder.new())
            return std.builder.build(builder)
        }
    }
}

/// Helper to escape characters into a StringBuilder.
let escape_chars_to_builder: fn(List[char], StringBuilder) -> StringBuilder =
    fn(chars: List[char], builder: StringBuilder) -> StringBuilder {
        match chars {
            Nil => { return builder }
            Cons(c, rest) => {
                let escaped_builder: StringBuilder = escape_char(c, builder)
                return escape_chars_to_builder(rest, escaped_builder)
            }
        }
    }

/// Escapes a single character into a StringBuilder.
/// Properly handles control characters using std.char.to_i32.
let escape_char: fn(char, StringBuilder) -> StringBuilder = fn(c: char, builder: StringBuilder) -> StringBuilder {
    let code: i32 = std.char.to_i32(c)

    // Check for characters that need escaping
    if code == 34 {  // Double quote "
        return std.builder.append(builder, "\\\"")
    }
    if code == 92 {  // Backslash \
        return std.builder.append(builder, "\\\\")
    }
    if code == 8 {   // Backspace \b
        return std.builder.append(builder, "\\b")
    }
    if code == 12 {  // Form feed \f
        return std.builder.append(builder, "\\f")
    }
    if code == 10 {  // Newline \n
        return std.builder.append(builder, "\\n")
    }
    if code == 13 {  // Carriage return \r
        return std.builder.append(builder, "\\r")
    }
    if code == 9 {   // Tab \t
        return std.builder.append(builder, "\\t")
    }

    // Escape other control characters (0x00-0x1F) as \uXXXX
    if code < 32 {
        return append_unicode_escape(builder, code)
    }

    // Regular character - append as-is
    return std.builder.append_char(builder, c)
}

/// Appends a \uXXXX escape sequence to the builder.
let append_unicode_escape: fn(StringBuilder, i32) -> StringBuilder = fn(builder: StringBuilder, code: i32) -> StringBuilder {
    let b1: StringBuilder = std.builder.append(builder, "\\u")
    let b2: StringBuilder = std.builder.append(b1, hex_digit_char((code / 4096) % 16))
    let b3: StringBuilder = std.builder.append(b2, hex_digit_char((code / 256) % 16))
    let b4: StringBuilder = std.builder.append(b3, hex_digit_char((code / 16) % 16))
    let b5: StringBuilder = std.builder.append(b4, hex_digit_char(code % 16))
    return b5
}

/// Converts a hex digit value (0-15) to its character representation.
let hex_digit_char: fn(i32) -> string = fn(n: i32) -> string {
    if n == 0 { return "0" }
    if n == 1 { return "1" }
    if n == 2 { return "2" }
    if n == 3 { return "3" }
    if n == 4 { return "4" }
    if n == 5 { return "5" }
    if n == 6 { return "6" }
    if n == 7 { return "7" }
    if n == 8 { return "8" }
    if n == 9 { return "9" }
    if n == 10 { return "a" }
    if n == 11 { return "b" }
    if n == 12 { return "c" }
    if n == 13 { return "d" }
    if n == 14 { return "e" }
    return "f"
}

// =============================================================================
// Stringify - Compact
// =============================================================================

/// Converts a JSON value to a compact string representation.
/// Uses StringBuilder for efficient string building.
pub let stringify: fn(Json) -> string = fn(json: Json) -> string {
    let builder: StringBuilder = stringify_to_builder(json, std.builder.new())
    return std.builder.build(builder)
}

/// Stringifies a JSON value into a StringBuilder.
let stringify_to_builder: fn(Json, StringBuilder) -> StringBuilder = fn(json: Json, builder: StringBuilder) -> StringBuilder {
    match json {
        JNull => { return std.builder.append(builder, "null") }
        JBool(b) => {
            if b {
                return std.builder.append(builder, "true")
            }
            return std.builder.append(builder, "false")
        }
        JNumber(n) => { return std.builder.append(builder, std.float.to_string(n)) }
        JString(s) => {
            let b1: StringBuilder = std.builder.append(builder, "\"")
            let b2: StringBuilder = std.builder.append(b1, escape_string(s))
            return std.builder.append(b2, "\"")
        }
        JArray(arr) => { return stringify_array_to_builder(arr, builder) }
        JObject(map) => { return stringify_object_map_to_builder(map, builder) }
    }
}

/// Stringifies an array into a StringBuilder.
let stringify_array_to_builder: fn(List[Json], StringBuilder) -> StringBuilder = fn(arr: List[Json], builder: StringBuilder) -> StringBuilder {
    let b1: StringBuilder = std.builder.append(builder, "[")
    let b2: StringBuilder = stringify_array_contents_to_builder(arr, b1, true)
    return std.builder.append(b2, "]")
}

/// Stringifies array contents with comma separation into a StringBuilder.
let stringify_array_contents_to_builder: fn(List[Json], StringBuilder, bool) -> StringBuilder =
    fn(arr: List[Json], builder: StringBuilder, is_first: bool) -> StringBuilder {
        match arr {
            Nil => { return builder }
            Cons(elem, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",")
                }
                let b2: StringBuilder = stringify_to_builder(elem, b)
                return stringify_array_contents_to_builder(rest, b2, false)
            }
        }
    }

/// Stringifies an object HashMap into a StringBuilder.
let stringify_object_map_to_builder: fn(HashMap, StringBuilder) -> StringBuilder = fn(map: HashMap, builder: StringBuilder) -> StringBuilder {
    let entries: List[(string, Json)] = std.map.entries(map)
    let b1: StringBuilder = std.builder.append(builder, "{")
    let b2: StringBuilder = stringify_entries_to_builder(entries, b1, true)
    return std.builder.append(b2, "}")
}

/// Stringifies map entries with comma separation into a StringBuilder.
let stringify_entries_to_builder: fn(List[(string, Json)], StringBuilder, bool) -> StringBuilder =
    fn(entries: List[(string, Json)], builder: StringBuilder, is_first: bool) -> StringBuilder {
        match entries {
            Nil => { return builder }
            Cons(entry, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",")
                }
                let b1: StringBuilder = std.builder.append(b, "\"")
                let b2: StringBuilder = std.builder.append(b1, escape_string(entry.0))
                let b3: StringBuilder = std.builder.append(b2, "\":")
                let b4: StringBuilder = stringify_to_builder(entry.1, b3)
                return stringify_entries_to_builder(rest, b4, false)
            }
        }
    }

// =============================================================================
// Stringify - Pretty
// =============================================================================

/// Converts a JSON value to a pretty-printed string with 2-space indentation.
/// Uses StringBuilder for efficient string building.
pub let stringify_pretty: fn(Json) -> string = fn(json: Json) -> string {
    return stringify_pretty_with(json, 2)
}

/// Converts a JSON value to a pretty-printed string with custom indentation.
pub let stringify_pretty_with: fn(Json, i32) -> string = fn(json: Json, indent_size: i32) -> string {
    let builder: StringBuilder = stringify_indent_to_builder(json, 0, indent_size, std.builder.new())
    return std.builder.build(builder)
}

/// Stringifies with indentation at the current level into a StringBuilder.
let stringify_indent_to_builder: fn(Json, i32, i32, StringBuilder) -> StringBuilder =
    fn(json: Json, level: i32, indent_size: i32, builder: StringBuilder) -> StringBuilder {
        match json {
            JNull => { return std.builder.append(builder, "null") }
            JBool(b) => {
                if b {
                    return std.builder.append(builder, "true")
                }
                return std.builder.append(builder, "false")
            }
            JNumber(n) => { return std.builder.append(builder, std.float.to_string(n)) }
            JString(s) => {
                let b1: StringBuilder = std.builder.append(builder, "\"")
                let b2: StringBuilder = std.builder.append(b1, escape_string(s))
                return std.builder.append(b2, "\"")
            }
            JArray(arr) => { return stringify_array_pretty_to_builder(arr, level, indent_size, builder) }
            JObject(map) => { return stringify_object_map_pretty_to_builder(map, level, indent_size, builder) }
        }
    }

/// Appends indentation (spaces) to a StringBuilder.
let append_indent: fn(StringBuilder, i32, i32) -> StringBuilder =
    fn(builder: StringBuilder, level: i32, indent_size: i32) -> StringBuilder {
        let total_spaces: i32 = level * indent_size
        return append_spaces(builder, total_spaces)
    }

/// Appends n spaces to a StringBuilder.
let append_spaces: fn(StringBuilder, i32) -> StringBuilder = fn(builder: StringBuilder, n: i32) -> StringBuilder {
    if n <= 0 {
        return builder
    }
    return append_spaces(std.builder.append(builder, " "), n - 1)
}

/// Pretty-prints an array into a StringBuilder.
let stringify_array_pretty_to_builder: fn(List[Json], i32, i32, StringBuilder) -> StringBuilder =
    fn(arr: List[Json], level: i32, indent_size: i32, builder: StringBuilder) -> StringBuilder {
        match arr {
            Nil => { return std.builder.append(builder, "[]") }
            _ => {
                let b1: StringBuilder = std.builder.append(builder, "[\n")
                let b2: StringBuilder = stringify_array_contents_pretty_to_builder(arr, level + 1, indent_size, b1, true)
                let b3: StringBuilder = std.builder.append(b2, "\n")
                let b4: StringBuilder = append_indent(b3, level, indent_size)
                return std.builder.append(b4, "]")
            }
        }
    }

/// Pretty-prints array contents into a StringBuilder.
let stringify_array_contents_pretty_to_builder: fn(List[Json], i32, i32, StringBuilder, bool) -> StringBuilder =
    fn(arr: List[Json], level: i32, indent_size: i32, builder: StringBuilder, is_first: bool) -> StringBuilder {
        match arr {
            Nil => { return builder }
            Cons(elem, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",\n")
                }
                let b1: StringBuilder = append_indent(b, level, indent_size)
                let b2: StringBuilder = stringify_indent_to_builder(elem, level, indent_size, b1)
                return stringify_array_contents_pretty_to_builder(rest, level, indent_size, b2, false)
            }
        }
    }

/// Pretty-prints an object HashMap into a StringBuilder.
let stringify_object_map_pretty_to_builder: fn(HashMap, i32, i32, StringBuilder) -> StringBuilder =
    fn(map: HashMap, level: i32, indent_size: i32, builder: StringBuilder) -> StringBuilder {
        if std.map.is_empty(map) {
            return std.builder.append(builder, "{}")
        }
        let entries: List[(string, Json)] = std.map.entries(map)
        let b1: StringBuilder = std.builder.append(builder, "{\n")
        let b2: StringBuilder = stringify_entries_pretty_to_builder(entries, level + 1, indent_size, b1, true)
        let b3: StringBuilder = std.builder.append(b2, "\n")
        let b4: StringBuilder = append_indent(b3, level, indent_size)
        return std.builder.append(b4, "}")
    }

/// Pretty-prints map entries into a StringBuilder.
let stringify_entries_pretty_to_builder: fn(List[(string, Json)], i32, i32, StringBuilder, bool) -> StringBuilder =
    fn(entries: List[(string, Json)], level: i32, indent_size: i32, builder: StringBuilder, is_first: bool) -> StringBuilder {
        match entries {
            Nil => { return builder }
            Cons(entry, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",\n")
                }
                let b1: StringBuilder = append_indent(b, level, indent_size)
                let b2: StringBuilder = std.builder.append(b1, "\"")
                let b3: StringBuilder = std.builder.append(b2, escape_string(entry.0))
                let b4: StringBuilder = std.builder.append(b3, "\": ")
                let b5: StringBuilder = stringify_indent_to_builder(entry.1, level, indent_size, b4)
                return stringify_entries_pretty_to_builder(rest, level, indent_size, b5, false)
            }
        }
    }
