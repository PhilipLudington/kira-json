/// JSON Parser Library for Kira
/// A pure functional JSON parsing, manipulation, and serialization library.

module json

// =============================================================================
// Core Types
// =============================================================================

/// Represents a JSON value.
/// JSON can be null, boolean, number, string, array, or object.
/// Note: JObject uses HashMap for O(1) field lookup.
pub type Json =
    | JNull
    | JBool(bool)
    | JNumber(f64)
    | JString(string)
    | JArray(List[Json])
    | JObject(HashMap)

/// A key-value pair in a JSON object.
pub type JsonField = {
    key: string,
    value: Json
}

/// Creates a JsonField from a key and value.
pub let make_field: fn(string, Json) -> JsonField = fn(key: string, value: Json) -> JsonField {
    return JsonField { key: key, value: value }
}

/// Error information from parsing, including position in the input.
/// @deprecated Use JsonError for pattern matching on specific error types.
pub type ParseError = {
    message: string,
    line: i32,
    column: i32
}

/// Structured error type for JSON parsing failures.
/// Enables pattern matching on specific error categories.
pub type JsonError =
    | UnexpectedEof { expected: string, context: string, line: i32, col: i32 }
    | UnexpectedToken { expected: string, found: string, line: i32, col: i32 }
    | UnterminatedString { line: i32, col: i32 }
    | InvalidEscape { sequence: string, reason: string, line: i32, col: i32 }
    | ControlChar { code: i32, line: i32, col: i32 }
    | InvalidNumber { value: string, reason: string, line: i32, col: i32 }
    | TrailingContent { found: string, line: i32, col: i32 }
    | MaxDepthExceeded { depth: i32, max_depth: i32, line: i32, col: i32 }
    | DuplicateKey { key: string, line: i32, col: i32 }

/// Converts a JsonError to a human-readable string.
pub let format_error: fn(JsonError) -> string = fn(err: JsonError) -> string {
    match err {
        DuplicateKey { key: k, line: l, col: c } => {
            return std.string.concat("Duplicate key '", std.string.concat(k, std.string.concat("' at line ", std.string.concat(std.int.to_string(l), std.string.concat(", column ", std.int.to_string(c))))))
        }
        InvalidNumber { value: val, reason: rsn, line: l, col: c } => {
            return std.string.concat("Invalid number '", std.string.concat(val, std.string.concat("' at line ", std.string.concat(std.int.to_string(l), std.string.concat(", column ", std.string.concat(std.int.to_string(c), std.string.concat(": ", rsn)))))))
        }
        InvalidEscape { sequence: seq, reason: rsn, line: l, col: c } => {
            return std.string.concat("Invalid escape sequence '", std.string.concat(seq, std.string.concat("' at line ", std.string.concat(std.int.to_string(l), std.string.concat(", column ", std.string.concat(std.int.to_string(c), std.string.concat(": ", rsn)))))))
        }
        UnexpectedEof { expected: exp, context: ctx, line: l, col: c } => {
            return std.string.concat("Unexpected end of input at line ", std.string.concat(std.int.to_string(l), std.string.concat(", column ", std.string.concat(std.int.to_string(c), std.string.concat(": expected ", std.string.concat(exp, std.string.concat(" in ", ctx)))))))
        }
        UnexpectedToken { expected: exp, found: fnd, line: l, col: c } => {
            return std.string.concat("Unexpected token at line ", std.string.concat(std.int.to_string(l), std.string.concat(", column ", std.string.concat(std.int.to_string(c), std.string.concat(": expected ", std.string.concat(exp, std.string.concat(", found '", std.string.concat(fnd, "'"))))))))
        }
        TrailingContent { found: fnd, line: l, col: c } => {
            return std.string.concat("Unexpected content after JSON value at line ", std.string.concat(std.int.to_string(l), std.string.concat(", column ", std.string.concat(std.int.to_string(c), std.string.concat(": found '", std.string.concat(fnd, "'"))))))
        }
        ControlChar { code: cd, line: l, col: c } => {
            return std.string.concat("Unescaped control character (code ", std.string.concat(std.int.to_string(cd), std.string.concat(") at line ", std.string.concat(std.int.to_string(l), std.string.concat(", column ", std.int.to_string(c))))))
        }
        UnterminatedString { line: l, col: c } => {
            return std.string.concat("Unterminated string at line ", std.string.concat(std.int.to_string(l), std.string.concat(", column ", std.int.to_string(c))))
        }
        MaxDepthExceeded { depth: d, max_depth: m, line: l, col: c } => {
            return std.string.concat("Maximum nesting depth exceeded at line ", std.string.concat(std.int.to_string(l), std.string.concat(", column ", std.string.concat(std.int.to_string(c), std.string.concat(": depth ", std.string.concat(std.int.to_string(d), std.string.concat(" exceeds limit ", std.int.to_string(m))))))))
        }
    }
}

/// Returns the line number from a JsonError.
pub let error_line: fn(JsonError) -> i32 = fn(err: JsonError) -> i32 {
    match err {
        DuplicateKey { key: _, line: l, col: _ } => { return l }
        InvalidNumber { value: _, reason: _, line: l, col: _ } => { return l }
        InvalidEscape { sequence: _, reason: _, line: l, col: _ } => { return l }
        UnexpectedEof { expected: _, context: _, line: l, col: _ } => { return l }
        UnexpectedToken { expected: _, found: _, line: l, col: _ } => { return l }
        TrailingContent { found: _, line: l, col: _ } => { return l }
        ControlChar { code: _, line: l, col: _ } => { return l }
        UnterminatedString { line: l, col: _ } => { return l }
        MaxDepthExceeded { depth: _, max_depth: _, line: l, col: _ } => { return l }
    }
}

/// Returns the column number from a JsonError.
pub let error_column: fn(JsonError) -> i32 = fn(err: JsonError) -> i32 {
    match err {
        DuplicateKey { key: _, line: _, col: c } => { return c }
        InvalidNumber { value: _, reason: _, line: _, col: c } => { return c }
        InvalidEscape { sequence: _, reason: _, line: _, col: c } => { return c }
        UnexpectedEof { expected: _, context: _, line: _, col: c } => { return c }
        UnexpectedToken { expected: _, found: _, line: _, col: c } => { return c }
        TrailingContent { found: _, line: _, col: c } => { return c }
        ControlChar { code: _, line: _, col: c } => { return c }
        UnterminatedString { line: _, col: c } => { return c }
        MaxDepthExceeded { depth: _, max_depth: _, line: _, col: c } => { return c }
    }
}


/// Default maximum nesting depth for JSON parsing.
/// This prevents stack overflow from deeply nested structures.
pub let default_max_depth: fn() -> i32 = fn() -> i32 {
    return 512
}

/// Internal state for the recursive descent parser.
type ParserState = {
    input: string,
    pos: i32,
    line: i32,
    column: i32,
    depth: i32,
    max_depth: i32,
    strict: bool
}

/// Result of a parse operation - either success with value and new state,
/// or failure with an error.
type ParseResult[T] =
    | ParseOk(T, ParserState)
    | ParseErr(JsonError)

// =============================================================================
// Type Checking Predicates
// =============================================================================

/// Returns true if the JSON value is null.
pub let is_null: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JNull => { return true }
        _ => { return false }
    }
}

/// Returns true if the JSON value is a boolean.
pub let is_bool: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JBool(_) => { return true }
        _ => { return false }
    }
}

/// Returns true if the JSON value is a number.
pub let is_number: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JNumber(_) => { return true }
        _ => { return false }
    }
}

/// Returns true if the JSON value is a string.
pub let is_string: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JString(_) => { return true }
        _ => { return false }
    }
}

/// Returns true if the JSON value is an array.
pub let is_array: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JArray(_) => { return true }
        _ => { return false }
    }
}

/// Returns true if the JSON value is an object.
pub let is_object: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JObject(_) => { return true }
        _ => { return false }
    }
}

/// Returns the type name of a JSON value as a string.
pub let type_name: fn(Json) -> string = fn(json: Json) -> string {
    match json {
        JNull => { return "null" }
        JBool(_) => { return "boolean" }
        JNumber(_) => { return "number" }
        JString(_) => { return "string" }
        JArray(_) => { return "array" }
        JObject(_) => { return "object" }
    }
}

// =============================================================================
// Value Extractors
// =============================================================================

/// Extracts the string value if the JSON is a string.
pub let as_string: fn(Json) -> Option[string] = fn(json: Json) -> Option[string] {
    match json {
        JString(s) => { return Some(s) }
        _ => { return None }
    }
}

/// Extracts the number value if the JSON is a number.
pub let as_number: fn(Json) -> Option[f64] = fn(json: Json) -> Option[f64] {
    match json {
        JNumber(n) => { return Some(n) }
        _ => { return None }
    }
}

/// Extracts the number as an integer if the JSON is a number.
/// Truncates the number towards zero.
pub let as_int: fn(Json) -> Option[i64] = fn(json: Json) -> Option[i64] {
    match json {
        JNumber(n) => { return Some(std.math.trunc_to_i64(n)) }
        _ => { return None }
    }
}

/// Extracts the boolean value if the JSON is a boolean.
pub let as_bool: fn(Json) -> Option[bool] = fn(json: Json) -> Option[bool] {
    match json {
        JBool(b) => { return Some(b) }
        _ => { return None }
    }
}

/// Extracts the array if the JSON is an array.
pub let as_array: fn(Json) -> Option[List[Json]] = fn(json: Json) -> Option[List[Json]] {
    match json {
        JArray(arr) => { return Some(arr) }
        _ => { return None }
    }
}

/// Extracts the object fields if the JSON is an object.
/// Converts the internal HashMap to a List[JsonField] for backward compatibility.
pub let as_object: fn(Json) -> Option[List[JsonField]] = fn(json: Json) -> Option[List[JsonField]] {
    match json {
        JObject(map) => { return Some(hashmap_to_fields(map)) }
        _ => { return None }
    }
}

/// Extracts the HashMap directly if the JSON is an object.
/// More efficient than as_object when you need HashMap operations.
pub let as_object_map: fn(Json) -> Option[HashMap] = fn(json: Json) -> Option[HashMap] {
    match json {
        JObject(map) => { return Some(map) }
        _ => { return None }
    }
}

/// Converts a HashMap to a List[JsonField].
let hashmap_to_fields: fn(HashMap) -> List[JsonField] = fn(map: HashMap) -> List[JsonField] {
    let entries: List[(string, Json)] = std.map.entries(map)
    return entries_to_fields(entries)
}

/// Converts a list of (string, Json) tuples to List[JsonField].
let entries_to_fields: fn(List[(string, Json)]) -> List[JsonField] =
    fn(entries: List[(string, Json)]) -> List[JsonField] {
        match entries {
            Nil => { return Nil }
            Cons(entry, rest) => {
                let field: JsonField = JsonField { key: entry.0, value: entry.1 }
                return Cons(field, entries_to_fields(rest))
            }
        }
    }

/// Converts a List[JsonField] to a HashMap.
let fields_to_hashmap: fn(List[JsonField]) -> HashMap = fn(fields: List[JsonField]) -> HashMap {
    return fields_to_hashmap_acc(fields, std.map.new())
}

/// Helper to convert fields to HashMap with accumulator.
let fields_to_hashmap_acc: fn(List[JsonField], HashMap) -> HashMap =
    fn(fields: List[JsonField], acc: HashMap) -> HashMap {
        match fields {
            Nil => { return acc }
            Cons(field, rest) => {
                let new_acc: HashMap = std.map.put(acc, field.key, field.value)
                return fields_to_hashmap_acc(rest, new_acc)
            }
        }
    }

// =============================================================================
// Field/Index Accessors
// =============================================================================

/// Gets a field value from a JSON object by key.
/// Returns None if not an object or key not found.
/// Uses O(1) HashMap lookup.
pub let get_field: fn(Json, string) -> Option[Json] = fn(json: Json, key: string) -> Option[Json] {
    match json {
        JObject(map) => { return std.map.get(map, key) }
        _ => { return None }
    }
}

/// Helper to find a field in a list of JsonFields.
/// Retained for backward compatibility with code that uses List[JsonField].
let find_field: fn(List[JsonField], string) -> Option[Json] =
    fn(fields: List[JsonField], key: string) -> Option[Json] {
        match fields {
            Nil => { return None }
            Cons(field, rest) => {
                if std.string.equals(field.key, key) {
                    return Some(field.value)
                }
                return find_field(rest, key)
            }
        }
    }

/// Gets an element from a JSON array by index.
/// Returns None if not an array or index out of bounds.
pub let get_index: fn(Json, i32) -> Option[Json] = fn(json: Json, index: i32) -> Option[Json] {
    match json {
        JArray(arr) => { return list_get(arr, index) }
        _ => { return None }
    }
}

/// Helper to get an element from a list by index.
let list_get: fn(List[Json], i32) -> Option[Json] = fn(list: List[Json], index: i32) -> Option[Json] {
    if index < 0 {
        return None
    }
    match list {
        Nil => { return None }
        Cons(head, tail) => {
            if index == 0 {
                return Some(head)
            }
            return list_get(tail, index - 1)
        }
    }
}

/// Returns the size of a JSON array or object.
/// Returns None for other types.
pub let size: fn(Json) -> Option[i32] = fn(json: Json) -> Option[i32] {
    match json {
        JArray(arr) => { return Some(list_length[Json](arr)) }
        JObject(map) => { return Some(std.map.size(map)) }
        _ => { return None }
    }
}

/// Helper to get the length of a list.
let list_length[T]: fn(List[T]) -> i32 = fn(list: List[T]) -> i32 {
    match list {
        Nil => { return 0 }
        Cons(_, tail) => { return 1 + list_length[T](tail) }
    }
}

/// Returns the keys of a JSON object.
/// Returns None if not an object.
pub let keys: fn(Json) -> Option[List[string]] = fn(json: Json) -> Option[List[string]] {
    match json {
        JObject(map) => { return Some(std.map.keys(map)) }
        _ => { return None }
    }
}

/// Helper to extract keys from a list of JsonFields.
/// Retained for backward compatibility.
let extract_keys: fn(List[JsonField]) -> List[string] = fn(fields: List[JsonField]) -> List[string] {
    match fields {
        Nil => { return Nil }
        Cons(field, rest) => { return Cons(field.key, extract_keys(rest)) }
    }
}

/// Returns the values of a JSON object.
/// Returns None if not an object.
pub let values: fn(Json) -> Option[List[Json]] = fn(json: Json) -> Option[List[Json]] {
    match json {
        JObject(map) => { return Some(std.map.values(map)) }
        _ => { return None }
    }
}

/// Helper to extract values from a list of JsonFields.
let extract_values: fn(List[JsonField]) -> List[Json] = fn(fields: List[JsonField]) -> List[Json] {
    match fields {
        Nil => { return Nil }
        Cons(field, rest) => { return Cons(field.value, extract_values(rest)) }
    }
}

// =============================================================================
// Serializer - String Escaping
// =============================================================================

/// Escapes a string for JSON output.
/// Uses std.string.chars for proper character iteration.
let escape_string: fn(string) -> string = fn(s: string) -> string {
    let chars: List[Char] = std.string.chars(s)
    let builder: StringBuilder = escape_chars_to_builder(chars, std.builder.new())
    return std.builder.build(builder)
}

/// Helper to escape characters into a StringBuilder.
let escape_chars_to_builder: fn(List[Char], StringBuilder) -> StringBuilder =
    fn(chars: List[Char], builder: StringBuilder) -> StringBuilder {
        match chars {
            Nil => { return builder }
            Cons(c, rest) => {
                let escaped_builder: StringBuilder = escape_char(c, builder)
                return escape_chars_to_builder(rest, escaped_builder)
            }
        }
    }

/// Escapes a single character into a StringBuilder.
/// Properly handles control characters using std.char.to_i32.
let escape_char: fn(Char, StringBuilder) -> StringBuilder = fn(c: Char, builder: StringBuilder) -> StringBuilder {
    let code: i32 = std.char.to_i32(c)

    // Check for characters that need escaping
    if code == 34 {  // Double quote "
        return std.builder.append(builder, "\\\"")
    }
    if code == 92 {  // Backslash \
        return std.builder.append(builder, "\\\\")
    }
    if code == 8 {   // Backspace \b
        return std.builder.append(builder, "\\b")
    }
    if code == 12 {  // Form feed \f
        return std.builder.append(builder, "\\f")
    }
    if code == 10 {  // Newline \n
        return std.builder.append(builder, "\\n")
    }
    if code == 13 {  // Carriage return \r
        return std.builder.append(builder, "\\r")
    }
    if code == 9 {   // Tab \t
        return std.builder.append(builder, "\\t")
    }

    // Escape other control characters (0x00-0x1F) as \uXXXX
    if code < 32 {
        return append_unicode_escape(builder, code)
    }

    // Regular character - append as-is
    return std.builder.append_char(builder, c)
}

/// Appends a \uXXXX escape sequence to the builder.
let append_unicode_escape: fn(StringBuilder, i32) -> StringBuilder = fn(builder: StringBuilder, code: i32) -> StringBuilder {
    let b1: StringBuilder = std.builder.append(builder, "\\u")
    let b2: StringBuilder = std.builder.append(b1, hex_digit_char((code / 4096) % 16))
    let b3: StringBuilder = std.builder.append(b2, hex_digit_char((code / 256) % 16))
    let b4: StringBuilder = std.builder.append(b3, hex_digit_char((code / 16) % 16))
    let b5: StringBuilder = std.builder.append(b4, hex_digit_char(code % 16))
    return b5
}

/// Converts a hex digit value (0-15) to its character representation.
let hex_digit_char: fn(i32) -> string = fn(n: i32) -> string {
    if n == 0 { return "0" }
    if n == 1 { return "1" }
    if n == 2 { return "2" }
    if n == 3 { return "3" }
    if n == 4 { return "4" }
    if n == 5 { return "5" }
    if n == 6 { return "6" }
    if n == 7 { return "7" }
    if n == 8 { return "8" }
    if n == 9 { return "9" }
    if n == 10 { return "a" }
    if n == 11 { return "b" }
    if n == 12 { return "c" }
    if n == 13 { return "d" }
    if n == 14 { return "e" }
    return "f"
}

/// Pads a string on the left to the specified length.
let pad_left_str: fn(string, i32, string) -> string = fn(s: string, len: i32, pad: string) -> string {
    let current_len: i32 = std.string.length(s)
    if current_len >= len {
        return s
    }
    return pad_left_str(std.string.concat(pad, s), len, pad)
}

// =============================================================================
// Serializer - Stringify
// =============================================================================

/// Converts a JSON value to a compact string representation.
/// Uses StringBuilder for efficient string building.
pub let stringify: fn(Json) -> string = fn(json: Json) -> string {
    let builder: StringBuilder = stringify_to_builder(json, std.builder.new())
    return std.builder.build(builder)
}

/// Stringifies a JSON value into a StringBuilder.
let stringify_to_builder: fn(Json, StringBuilder) -> StringBuilder = fn(json: Json, builder: StringBuilder) -> StringBuilder {
    match json {
        JNull => { return std.builder.append(builder, "null") }
        JBool(b) => {
            if b {
                return std.builder.append(builder, "true")
            }
            return std.builder.append(builder, "false")
        }
        JNumber(n) => { return std.builder.append(builder, std.float.to_string(n)) }
        JString(s) => {
            let b1: StringBuilder = std.builder.append(builder, "\"")
            let b2: StringBuilder = std.builder.append(b1, escape_string(s))
            return std.builder.append(b2, "\"")
        }
        JArray(arr) => { return stringify_array_to_builder(arr, builder) }
        JObject(map) => { return stringify_object_map_to_builder(map, builder) }
    }
}

/// Stringifies an array into a StringBuilder.
let stringify_array_to_builder: fn(List[Json], StringBuilder) -> StringBuilder = fn(arr: List[Json], builder: StringBuilder) -> StringBuilder {
    let b1: StringBuilder = std.builder.append(builder, "[")
    let b2: StringBuilder = stringify_array_contents_to_builder(arr, b1, true)
    return std.builder.append(b2, "]")
}

/// Stringifies array contents with comma separation into a StringBuilder.
let stringify_array_contents_to_builder: fn(List[Json], StringBuilder, bool) -> StringBuilder =
    fn(arr: List[Json], builder: StringBuilder, is_first: bool) -> StringBuilder {
        match arr {
            Nil => { return builder }
            Cons(elem, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",")
                }
                let b2: StringBuilder = stringify_to_builder(elem, b)
                return stringify_array_contents_to_builder(rest, b2, false)
            }
        }
    }

/// Stringifies an object HashMap into a StringBuilder.
let stringify_object_map_to_builder: fn(HashMap, StringBuilder) -> StringBuilder = fn(map: HashMap, builder: StringBuilder) -> StringBuilder {
    let entries: List[(string, Json)] = std.map.entries(map)
    let b1: StringBuilder = std.builder.append(builder, "{")
    let b2: StringBuilder = stringify_entries_to_builder(entries, b1, true)
    return std.builder.append(b2, "}")
}

/// Stringifies map entries with comma separation into a StringBuilder.
let stringify_entries_to_builder: fn(List[(string, Json)], StringBuilder, bool) -> StringBuilder =
    fn(entries: List[(string, Json)], builder: StringBuilder, is_first: bool) -> StringBuilder {
        match entries {
            Nil => { return builder }
            Cons(entry, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",")
                }
                let b1: StringBuilder = std.builder.append(b, "\"")
                let b2: StringBuilder = std.builder.append(b1, escape_string(entry.0))
                let b3: StringBuilder = std.builder.append(b2, "\":")
                let b4: StringBuilder = stringify_to_builder(entry.1, b3)
                return stringify_entries_to_builder(rest, b4, false)
            }
        }
    }

/// Stringifies an object into a StringBuilder (List[JsonField] version).
/// Retained for backward compatibility.
let stringify_object_to_builder: fn(List[JsonField], StringBuilder) -> StringBuilder = fn(fields: List[JsonField], builder: StringBuilder) -> StringBuilder {
    let b1: StringBuilder = std.builder.append(builder, "{")
    let b2: StringBuilder = stringify_object_contents_to_builder(fields, b1, true)
    return std.builder.append(b2, "}")
}

/// Stringifies object contents with comma separation into a StringBuilder.
let stringify_object_contents_to_builder: fn(List[JsonField], StringBuilder, bool) -> StringBuilder =
    fn(fields: List[JsonField], builder: StringBuilder, is_first: bool) -> StringBuilder {
        match fields {
            Nil => { return builder }
            Cons(field, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",")
                }
                let b1: StringBuilder = std.builder.append(b, "\"")
                let b2: StringBuilder = std.builder.append(b1, escape_string(field.key))
                let b3: StringBuilder = std.builder.append(b2, "\":")
                let b4: StringBuilder = stringify_to_builder(field.value, b3)
                return stringify_object_contents_to_builder(rest, b4, false)
            }
        }
    }

/// Converts a JSON value to a pretty-printed string with 2-space indentation.
/// Uses StringBuilder for efficient string building.
pub let stringify_pretty: fn(Json) -> string = fn(json: Json) -> string {
    return stringify_pretty_with(json, 2)
}

/// Converts a JSON value to a pretty-printed string with custom indentation.
pub let stringify_pretty_with: fn(Json, i32) -> string = fn(json: Json, indent_size: i32) -> string {
    let builder: StringBuilder = stringify_indent_to_builder(json, 0, indent_size, std.builder.new())
    return std.builder.build(builder)
}

/// Stringifies with indentation at the current level into a StringBuilder.
let stringify_indent_to_builder: fn(Json, i32, i32, StringBuilder) -> StringBuilder =
    fn(json: Json, level: i32, indent_size: i32, builder: StringBuilder) -> StringBuilder {
        match json {
            JNull => { return std.builder.append(builder, "null") }
            JBool(b) => {
                if b {
                    return std.builder.append(builder, "true")
                }
                return std.builder.append(builder, "false")
            }
            JNumber(n) => { return std.builder.append(builder, std.float.to_string(n)) }
            JString(s) => {
                let b1: StringBuilder = std.builder.append(builder, "\"")
                let b2: StringBuilder = std.builder.append(b1, escape_string(s))
                return std.builder.append(b2, "\"")
            }
            JArray(arr) => { return stringify_array_pretty_to_builder(arr, level, indent_size, builder) }
            JObject(map) => { return stringify_object_map_pretty_to_builder(map, level, indent_size, builder) }
        }
    }

/// Appends indentation (spaces) to a StringBuilder.
let append_indent: fn(StringBuilder, i32, i32) -> StringBuilder =
    fn(builder: StringBuilder, level: i32, indent_size: i32) -> StringBuilder {
        let total_spaces: i32 = level * indent_size
        return append_spaces(builder, total_spaces)
    }

/// Appends n spaces to a StringBuilder.
let append_spaces: fn(StringBuilder, i32) -> StringBuilder = fn(builder: StringBuilder, n: i32) -> StringBuilder {
    if n <= 0 {
        return builder
    }
    return append_spaces(std.builder.append(builder, " "), n - 1)
}

/// Pretty-prints an array into a StringBuilder.
let stringify_array_pretty_to_builder: fn(List[Json], i32, i32, StringBuilder) -> StringBuilder =
    fn(arr: List[Json], level: i32, indent_size: i32, builder: StringBuilder) -> StringBuilder {
        match arr {
            Nil => { return std.builder.append(builder, "[]") }
            _ => {
                let b1: StringBuilder = std.builder.append(builder, "[\n")
                let b2: StringBuilder = stringify_array_contents_pretty_to_builder(arr, level + 1, indent_size, b1, true)
                let b3: StringBuilder = std.builder.append(b2, "\n")
                let b4: StringBuilder = append_indent(b3, level, indent_size)
                return std.builder.append(b4, "]")
            }
        }
    }

/// Pretty-prints array contents into a StringBuilder.
let stringify_array_contents_pretty_to_builder: fn(List[Json], i32, i32, StringBuilder, bool) -> StringBuilder =
    fn(arr: List[Json], level: i32, indent_size: i32, builder: StringBuilder, is_first: bool) -> StringBuilder {
        match arr {
            Nil => { return builder }
            Cons(elem, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",\n")
                }
                let b1: StringBuilder = append_indent(b, level, indent_size)
                let b2: StringBuilder = stringify_indent_to_builder(elem, level, indent_size, b1)
                return stringify_array_contents_pretty_to_builder(rest, level, indent_size, b2, false)
            }
        }
    }

/// Pretty-prints an object HashMap into a StringBuilder.
let stringify_object_map_pretty_to_builder: fn(HashMap, i32, i32, StringBuilder) -> StringBuilder =
    fn(map: HashMap, level: i32, indent_size: i32, builder: StringBuilder) -> StringBuilder {
        if std.map.is_empty(map) {
            return std.builder.append(builder, "{}")
        }
        let entries: List[(string, Json)] = std.map.entries(map)
        let b1: StringBuilder = std.builder.append(builder, "{\n")
        let b2: StringBuilder = stringify_entries_pretty_to_builder(entries, level + 1, indent_size, b1, true)
        let b3: StringBuilder = std.builder.append(b2, "\n")
        let b4: StringBuilder = append_indent(b3, level, indent_size)
        return std.builder.append(b4, "}")
    }

/// Pretty-prints map entries into a StringBuilder.
let stringify_entries_pretty_to_builder: fn(List[(string, Json)], i32, i32, StringBuilder, bool) -> StringBuilder =
    fn(entries: List[(string, Json)], level: i32, indent_size: i32, builder: StringBuilder, is_first: bool) -> StringBuilder {
        match entries {
            Nil => { return builder }
            Cons(entry, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",\n")
                }
                let b1: StringBuilder = append_indent(b, level, indent_size)
                let b2: StringBuilder = std.builder.append(b1, "\"")
                let b3: StringBuilder = std.builder.append(b2, escape_string(entry.0))
                let b4: StringBuilder = std.builder.append(b3, "\": ")
                let b5: StringBuilder = stringify_indent_to_builder(entry.1, level, indent_size, b4)
                return stringify_entries_pretty_to_builder(rest, level, indent_size, b5, false)
            }
        }
    }

/// Pretty-prints an object into a StringBuilder (List[JsonField] version).
/// Retained for backward compatibility.
let stringify_object_pretty_to_builder: fn(List[JsonField], i32, i32, StringBuilder) -> StringBuilder =
    fn(fields: List[JsonField], level: i32, indent_size: i32, builder: StringBuilder) -> StringBuilder {
        match fields {
            Nil => { return std.builder.append(builder, "{}") }
            _ => {
                let b1: StringBuilder = std.builder.append(builder, "{\n")
                let b2: StringBuilder = stringify_object_contents_pretty_to_builder(fields, level + 1, indent_size, b1, true)
                let b3: StringBuilder = std.builder.append(b2, "\n")
                let b4: StringBuilder = append_indent(b3, level, indent_size)
                return std.builder.append(b4, "}")
            }
        }
    }

/// Pretty-prints object contents into a StringBuilder.
/// Retained for backward compatibility.
let stringify_object_contents_pretty_to_builder: fn(List[JsonField], i32, i32, StringBuilder, bool) -> StringBuilder =
    fn(fields: List[JsonField], level: i32, indent_size: i32, builder: StringBuilder, is_first: bool) -> StringBuilder {
        match fields {
            Nil => { return builder }
            Cons(field, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",\n")
                }
                let b1: StringBuilder = append_indent(b, level, indent_size)
                let b2: StringBuilder = std.builder.append(b1, "\"")
                let b3: StringBuilder = std.builder.append(b2, escape_string(field.key))
                let b4: StringBuilder = std.builder.append(b3, "\": ")
                let b5: StringBuilder = stringify_indent_to_builder(field.value, level, indent_size, b4)
                return stringify_object_contents_pretty_to_builder(rest, level, indent_size, b5, false)
            }
        }
    }

// =============================================================================
// Parser - State Utilities
// =============================================================================

/// Creates an initial parser state from an input string with default max depth.
let init_state: fn(string) -> ParserState = fn(input: string) -> ParserState {
    return ParserState {
        input: input,
        pos: 0,
        line: 1,
        column: 1,
        depth: 0,
        max_depth: default_max_depth(),
        strict: false
    }
}

/// Creates an initial parser state with a custom max depth.
let init_state_with_depth: fn(string, i32) -> ParserState = fn(input: string, max_depth: i32) -> ParserState {
    return ParserState {
        input: input,
        pos: 0,
        line: 1,
        column: 1,
        depth: 0,
        max_depth: max_depth,
        strict: false
    }
}

/// Creates an initial parser state with strict mode and custom max depth.
let init_state_strict: fn(string, i32, bool) -> ParserState = fn(input: string, max_depth: i32, strict: bool) -> ParserState {
    return ParserState {
        input: input,
        pos: 0,
        line: 1,
        column: 1,
        depth: 0,
        max_depth: max_depth,
        strict: strict
    }
}

/// Increments the depth and returns a new state, or None if max depth exceeded.
let increment_depth: fn(ParserState) -> Option[ParserState] = fn(state: ParserState) -> Option[ParserState] {
    let new_depth: i32 = state.depth + 1
    if new_depth > state.max_depth {
        return None
    }
    return Some(ParserState {
        input: state.input,
        pos: state.pos,
        line: state.line,
        column: state.column,
        depth: new_depth,
        max_depth: state.max_depth,
        strict: state.strict
    })
}

/// Decrements the depth and returns a new state.
let decrement_depth: fn(ParserState) -> ParserState = fn(state: ParserState) -> ParserState {
    return ParserState {
        input: state.input,
        pos: state.pos,
        line: state.line,
        column: state.column,
        depth: state.depth - 1,
        max_depth: state.max_depth,
        strict: state.strict
    }
}

/// Helper to get the character code from a single-character string.
let get_char_code: fn(string) -> i32 = fn(s: string) -> i32 {
    let chars: List[Char] = std.string.chars(s)
    match chars {
        Cons(ch, Nil) => { return std.char.to_i32(ch) }
        _ => { return 0 }
    }
}

/// Returns true if the parser has reached the end of input.
let is_eof: fn(ParserState) -> bool = fn(state: ParserState) -> bool {
    return state.pos >= std.string.length(state.input)
}

/// Returns the current character as a string without consuming it.
let peek_str: fn(ParserState) -> Option[string] = fn(state: ParserState) -> Option[string] {
    if is_eof(state) {
        return None
    }
    return Some(std.string.substring(state.input, state.pos, state.pos + 1))
}

/// Returns the character at a given offset as a string.
let peek_at_str: fn(ParserState, i32) -> Option[string] = fn(state: ParserState, offset: i32) -> Option[string] {
    let target_pos: i32 = state.pos + offset
    if target_pos >= std.string.length(state.input) {
        return None
    }
    return Some(std.string.substring(state.input, target_pos, target_pos + 1))
}

/// Advances the parser by one character, updating line/column tracking.
let advance: fn(ParserState) -> ParserState = fn(state: ParserState) -> ParserState {
    if is_eof(state) {
        return state
    }
    let c: string = std.string.substring(state.input, state.pos, state.pos + 1)
    var new_line: i32 = state.line
    var new_column: i32 = state.column
    if std.string.equals(c, "\n") {
        new_line = state.line + 1
        new_column = 1
    } else {
        new_column = state.column + 1
    }
    return ParserState {
        input: state.input,
        pos: state.pos + 1,
        line: new_line,
        column: new_column,
        depth: state.depth,
        max_depth: state.max_depth,
        strict: state.strict
    }
}

/// Skips whitespace characters.
let skip_whitespace: fn(ParserState) -> ParserState = fn(state: ParserState) -> ParserState {
    match peek_str(state) {
        None => { return state }
        Some(c) => {
            if is_whitespace_str(c) {
                return skip_whitespace(advance(state))
            }
            return state
        }
    }
}

/// Returns true if the string is a whitespace character.
let is_whitespace_str: fn(string) -> bool = fn(c: string) -> bool {
    return std.string.equals(c, " ") or std.string.equals(c, "\t") or
           std.string.equals(c, "\n") or std.string.equals(c, "\r")
}

// =============================================================================
// Parser - Character Utilities (String-Based)
// =============================================================================

/// Returns true if the string (single char) is a digit (0-9).
let is_digit_str: fn(string) -> bool = fn(c: string) -> bool {
    return std.string.equals(c, "0") or std.string.equals(c, "1") or
           std.string.equals(c, "2") or std.string.equals(c, "3") or
           std.string.equals(c, "4") or std.string.equals(c, "5") or
           std.string.equals(c, "6") or std.string.equals(c, "7") or
           std.string.equals(c, "8") or std.string.equals(c, "9")
}

/// Returns true if the string (single char) is a hex digit (0-9, a-f, A-F).
let is_hex_digit_str: fn(string) -> bool = fn(c: string) -> bool {
    return is_digit_str(c) or
           std.string.equals(c, "a") or std.string.equals(c, "b") or
           std.string.equals(c, "c") or std.string.equals(c, "d") or
           std.string.equals(c, "e") or std.string.equals(c, "f") or
           std.string.equals(c, "A") or std.string.equals(c, "B") or
           std.string.equals(c, "C") or std.string.equals(c, "D") or
           std.string.equals(c, "E") or std.string.equals(c, "F")
}

/// Returns true if the string (single char) is a control character (0x00-0x1F).
/// These must be escaped in JSON strings.
let is_control_char_str: fn(string) -> bool = fn(c: string) -> bool {
    let chars: List[Char] = std.string.chars(c)
    match chars {
        Cons(ch, Nil) => {
            let code: i32 = std.char.to_i32(ch)
            return code >= 0 and code <= 31
        }
        _ => { return false }
    }
}

/// Converts a hex digit string to its integer value.
let hex_digit_value_str: fn(string) -> i32 = fn(c: string) -> i32 {
    if std.string.equals(c, "0") { return 0 }
    if std.string.equals(c, "1") { return 1 }
    if std.string.equals(c, "2") { return 2 }
    if std.string.equals(c, "3") { return 3 }
    if std.string.equals(c, "4") { return 4 }
    if std.string.equals(c, "5") { return 5 }
    if std.string.equals(c, "6") { return 6 }
    if std.string.equals(c, "7") { return 7 }
    if std.string.equals(c, "8") { return 8 }
    if std.string.equals(c, "9") { return 9 }
    if std.string.equals(c, "a") or std.string.equals(c, "A") { return 10 }
    if std.string.equals(c, "b") or std.string.equals(c, "B") { return 11 }
    if std.string.equals(c, "c") or std.string.equals(c, "C") { return 12 }
    if std.string.equals(c, "d") or std.string.equals(c, "D") { return 13 }
    if std.string.equals(c, "e") or std.string.equals(c, "E") { return 14 }
    if std.string.equals(c, "f") or std.string.equals(c, "F") { return 15 }
    return 0
}

// =============================================================================
// Parser - Literal Parsers
// =============================================================================

/// Parses the literal "null".
let parse_null: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    let result: ParseResult[string] = expect_literal(state, "null")
    match result {
        ParseOk(_, new_state) => { return ParseOk(JNull, new_state) }
        ParseErr(e) => { return ParseErr(e) }
    }
}

/// Parses a boolean literal ("true" or "false").
let parse_bool: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    match peek_str(state) {
        Some(c) => {
            if std.string.equals(c, "t") {
                let result: ParseResult[string] = expect_literal(state, "true")
                match result {
                    ParseOk(_, new_state) => { return ParseOk(JBool(true), new_state) }
                    ParseErr(e) => { return ParseErr(e) }
                }
            }
            if std.string.equals(c, "f") {
                let result: ParseResult[string] = expect_literal(state, "false")
                match result {
                    ParseOk(_, new_state) => { return ParseOk(JBool(false), new_state) }
                    ParseErr(e) => { return ParseErr(e) }
                }
            }
            return ParseErr(UnexpectedToken { expected: "'true' or 'false'", found: c, line: state.line, col: state.column })
        }
        None => { return ParseErr(UnexpectedEof { expected: "'true' or 'false'", context: "boolean literal", line: state.line, col: state.column }) }
    }
}

/// Expects a specific string literal at the current position.
/// Uses index-based comparison to avoid std.string.to_chars.
let expect_literal: fn(ParserState, string) -> ParseResult[string] =
    fn(state: ParserState, expected: string) -> ParseResult[string] {
        let expected_len: i32 = std.string.length(expected)
        return expect_literal_from(state, expected, 0, expected_len)
    }

/// Helper for expect_literal with index tracking.
let expect_literal_from: fn(ParserState, string, i32, i32) -> ParseResult[string] =
    fn(state: ParserState, expected: string, index: i32, len: i32) -> ParseResult[string] {
        if index >= len {
            return ParseOk(expected, state)
        }
        match peek_str(state) {
            None => {
                return ParseErr(UnexpectedEof { expected: expected, context: "literal", line: state.line, col: state.column })
            }
            Some(actual) => {
                let expected_char: string = std.string.substring(expected, index, index + 1)
                if std.string.equals(actual, expected_char) {
                    return expect_literal_from(advance(state), expected, index + 1, len)
                }
                return ParseErr(UnexpectedToken { expected: expected_char, found: actual, line: state.line, col: state.column })
            }
        }
    }

// =============================================================================
// Parser - Number Parser
// =============================================================================

/// Parses a JSON number.
let parse_number: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    let start_pos: i32 = state.pos
    var current_state: ParserState = state

    // Handle optional negative sign
    match peek_str(current_state) {
        Some(c) => {
            if std.string.equals(c, "-") {
                current_state = advance(current_state)
            }
        }
        None => {}
    }

    // Parse integer part
    match peek_str(current_state) {
        Some(c) => {
            if std.string.equals(c, "0") {
                current_state = advance(current_state)
                // Check for leading zeros (invalid in JSON)
                // After a leading 0, only '.', 'e', 'E', or end of number is valid
                match peek_str(current_state) {
                    Some(next) => {
                        if is_digit_str(next) {
                            let partial: string = std.string.substring(state.input, start_pos, current_state.pos + 1)
                            return ParseErr(InvalidNumber { value: partial, reason: "leading zeros are not allowed", line: current_state.line, col: current_state.column })
                        }
                    }
                    None => {}
                }
            } else if is_digit_str(c) {
                current_state = consume_digits_str(current_state)
            } else {
                return ParseErr(UnexpectedToken { expected: "digit", found: c, line: current_state.line, col: current_state.column })
            }
        }
        None => { return ParseErr(UnexpectedEof { expected: "digit", context: "number", line: current_state.line, col: current_state.column }) }
    }

    // Parse optional fractional part
    match peek_str(current_state) {
        Some(c) => {
            if std.string.equals(c, ".") {
                current_state = advance(current_state)
                match peek_str(current_state) {
                    Some(d) => {
                        if is_digit_str(d) {
                            current_state = consume_digits_str(current_state)
                        } else {
                            let partial: string = std.string.substring(state.input, start_pos, current_state.pos)
                            return ParseErr(InvalidNumber { value: partial, reason: "expected digit after decimal point", line: current_state.line, col: current_state.column })
                        }
                    }
                    None => {
                        let partial: string = std.string.substring(state.input, start_pos, current_state.pos)
                        return ParseErr(InvalidNumber { value: partial, reason: "expected digit after decimal point", line: current_state.line, col: current_state.column })
                    }
                }
            }
        }
        None => {}
    }

    // Parse optional exponent
    match peek_str(current_state) {
        Some(c) => {
            if std.string.equals(c, "e") or std.string.equals(c, "E") {
                current_state = advance(current_state)
                match peek_str(current_state) {
                    Some(sign) => {
                        if std.string.equals(sign, "+") or std.string.equals(sign, "-") {
                            current_state = advance(current_state)
                        }
                    }
                    None => {}
                }
                match peek_str(current_state) {
                    Some(d) => {
                        if is_digit_str(d) {
                            current_state = consume_digits_str(current_state)
                        } else {
                            let partial: string = std.string.substring(state.input, start_pos, current_state.pos)
                            return ParseErr(InvalidNumber { value: partial, reason: "expected digit in exponent", line: current_state.line, col: current_state.column })
                        }
                    }
                    None => {
                        let partial: string = std.string.substring(state.input, start_pos, current_state.pos)
                        return ParseErr(InvalidNumber { value: partial, reason: "expected digit in exponent", line: current_state.line, col: current_state.column })
                    }
                }
            }
        }
        None => {}
    }

    let num_str: string = std.string.substring(state.input, start_pos, current_state.pos)
    match std.float.parse(num_str) {
        Some(n) => {
            // Reject NaN and Infinity (not valid JSON values)
            if std.float.is_nan(n) {
                return ParseErr(InvalidNumber { value: num_str, reason: "NaN is not valid in JSON", line: state.line, col: state.column })
            }
            if std.float.is_infinite(n) {
                return ParseErr(InvalidNumber { value: num_str, reason: "Infinity is not valid in JSON", line: state.line, col: state.column })
            }
            return ParseOk(JNumber(n), current_state)
        }
        None => { return ParseErr(InvalidNumber { value: num_str, reason: "invalid number format", line: state.line, col: state.column }) }
    }
}

/// Consumes digits and returns the new state.
let consume_digits_str: fn(ParserState) -> ParserState = fn(state: ParserState) -> ParserState {
    match peek_str(state) {
        Some(c) => {
            if is_digit_str(c) {
                return consume_digits_str(advance(state))
            }
            return state
        }
        None => { return state }
    }
}

// =============================================================================
// Parser - String Parser
// =============================================================================

/// Parses a JSON string (including the surrounding quotes).
let parse_string: fn(ParserState) -> ParseResult[string] = fn(state: ParserState) -> ParseResult[string] {
    match peek_str(state) {
        Some(c) => {
            if std.string.equals(c, "\"") {
                let after_quote: ParserState = advance(state)
                return parse_string_contents_str(after_quote, "")
            }
            return ParseErr(UnexpectedToken { expected: "'\"'", found: c, line: state.line, col: state.column })
        }
        None => { return ParseErr(UnexpectedEof { expected: "'\"'", context: "string", line: state.line, col: state.column }) }
    }
}

/// Parses the contents of a string until the closing quote.
/// Uses StringBuilder for O(n) string building instead of O(nÂ²) concatenation.
let parse_string_contents_str: fn(ParserState, string) -> ParseResult[string] =
    fn(state: ParserState, _acc: string) -> ParseResult[string] {
        let builder: StringBuilder = std.builder.new()
        return parse_string_contents_builder(state, builder)
    }

/// Internal helper that uses StringBuilder for efficient string accumulation.
/// Uses iterative approach (while loop) instead of recursion to avoid stack overflow
/// on long strings.
let parse_string_contents_builder: fn(ParserState, StringBuilder) -> ParseResult[string] =
    fn(state: ParserState, builder: StringBuilder) -> ParseResult[string] {
        var current_state: ParserState = state
        var current_builder: StringBuilder = builder

        while true {
            match peek_str(current_state) {
                None => { return ParseErr(UnterminatedString { line: current_state.line, col: current_state.column }) }
                Some(c) => {
                    if std.string.equals(c, "\"") {
                        // Found closing quote - return the built string
                        return ParseOk(std.builder.build(current_builder), advance(current_state))
                    }
                    if std.string.equals(c, "\\") {
                        // Handle escape sequence
                        let escape_result: ParseResult[string] = parse_escape_sequence_str(advance(current_state))
                        match escape_result {
                            ParseOk(escaped, new_state) => {
                                current_builder = std.builder.append(current_builder, escaped)
                                current_state = new_state
                                // Continue loop (no recursive call)
                            }
                            ParseErr(e) => { return ParseErr(e) }
                        }
                    } else {
                        // Not a backslash - check for control characters
                        if is_control_char_str(c) {
                            let code: i32 = get_char_code(c)
                            return ParseErr(ControlChar { code: code, line: current_state.line, col: current_state.column })
                        }
                        // Regular character - add to builder and advance
                        current_builder = std.builder.append(current_builder, c)
                        current_state = advance(current_state)
                    }
                }
            }
        }
    }

/// Parses an escape sequence (after the backslash).
/// Returns the escaped character as a string.
let parse_escape_sequence_str: fn(ParserState) -> ParseResult[string] = fn(state: ParserState) -> ParseResult[string] {
    match peek_str(state) {
        None => { return ParseErr(InvalidEscape { sequence: "\\", reason: "unexpected end of input", line: state.line, col: state.column }) }
        Some(c) => {
            if std.string.equals(c, "\"") { return ParseOk("\"", advance(state)) }
            if std.string.equals(c, "\\") { return ParseOk("\\", advance(state)) }
            if std.string.equals(c, "/") { return ParseOk("/", advance(state)) }
            if std.string.equals(c, "b") { return ParseOk("\b", advance(state)) }
            if std.string.equals(c, "f") { return ParseOk("\f", advance(state)) }
            if std.string.equals(c, "n") { return ParseOk("\n", advance(state)) }
            if std.string.equals(c, "r") { return ParseOk("\r", advance(state)) }
            if std.string.equals(c, "t") { return ParseOk("\t", advance(state)) }
            if std.string.equals(c, "u") { return parse_unicode_escape_str(advance(state)) }
            let seq: string = std.string.concat("\\", c)
            return ParseErr(InvalidEscape { sequence: seq, reason: "unknown escape character", line: state.line, col: state.column })
        }
    }
}

/// Checks if a code point is a high surrogate (U+D800 to U+DBFF).
let is_high_surrogate: fn(i32) -> bool = fn(code: i32) -> bool {
    return code >= 55296 and code <= 56319  // 0xD800 to 0xDBFF
}

/// Checks if a code point is a low surrogate (U+DC00 to U+DFFF).
let is_low_surrogate: fn(i32) -> bool = fn(code: i32) -> bool {
    return code >= 56320 and code <= 57343  // 0xDC00 to 0xDFFF
}

/// Combines a high and low surrogate pair into the actual Unicode code point.
/// Formula: 0x10000 + ((high - 0xD800) << 10) + (low - 0xDC00)
let combine_surrogates: fn(i32, i32) -> i32 = fn(high: i32, low: i32) -> i32 {
    return 65536 + ((high - 55296) * 1024) + (low - 56320)
}

/// Parses 4 hex digits and returns the code point value.
/// Returns ParseErr if not exactly 4 valid hex digits.
let parse_4_hex_digits: fn(ParserState) -> ParseResult[i32] = fn(state: ParserState) -> ParseResult[i32] {
    var current_state: ParserState = state
    var code_point: i32 = 0

    var i: i32 = 0
    while i < 4 {
        match peek_str(current_state) {
            None => { return ParseErr(InvalidEscape { sequence: "\\u", reason: "incomplete unicode escape", line: current_state.line, col: current_state.column }) }
            Some(c) => {
                if not is_hex_digit_str(c) {
                    let seq: string = std.string.concat("\\u", c)
                    return ParseErr(InvalidEscape { sequence: seq, reason: "invalid hex digit", line: current_state.line, col: current_state.column })
                }
                code_point = code_point * 16 + hex_digit_value_str(c)
                current_state = advance(current_state)
            }
        }
        i = i + 1
    }

    return ParseOk(code_point, current_state)
}

/// Parses a \uXXXX unicode escape sequence.
/// Handles UTF-16 surrogate pairs: \uD83D\uDE00 becomes a single emoji.
/// Converts the hex code point to a character using std.char.from_i32.
let parse_unicode_escape_str: fn(ParserState) -> ParseResult[string] = fn(state: ParserState) -> ParseResult[string] {
    // Parse the first 4 hex digits
    match parse_4_hex_digits(state) {
        ParseErr(e) => { return ParseErr(e) }
        ParseOk(code_point, after_first) => {
            // Check if this is a high surrogate (start of a pair)
            if is_high_surrogate(code_point) {
                // Must be followed by \uXXXX with a low surrogate
                match peek_str(after_first) {
                    None => {
                        // Lone high surrogate at end of input - use replacement character
                        return ParseOk("\uFFFD", after_first)
                    }
                    Some(c1) => {
                        if std.string.equals(c1, "\\") {
                            let after_backslash: ParserState = advance(after_first)
                            match peek_str(after_backslash) {
                                None => {
                                    // Backslash at end - lone high surrogate
                                    return ParseOk("\uFFFD", after_first)
                                }
                                Some(c2) => {
                                    if std.string.equals(c2, "u") {
                                        // Try to parse the second escape
                                        let after_u: ParserState = advance(after_backslash)
                                        match parse_4_hex_digits(after_u) {
                                            ParseErr(_) => {
                                                // Invalid second escape - lone high surrogate
                                                return ParseOk("\uFFFD", after_first)
                                            }
                                            ParseOk(second_code, after_second) => {
                                                if is_low_surrogate(second_code) {
                                                    // Valid surrogate pair - combine them
                                                    let combined: i32 = combine_surrogates(code_point, second_code)
                                                    match std.char.from_i32(combined) {
                                                        Some(ch) => {
                                                            let b: StringBuilder = std.builder.new()
                                                            let b2: StringBuilder = std.builder.append_char(b, ch)
                                                            return ParseOk(std.builder.build(b2), after_second)
                                                        }
                                                        None => {
                                                            // Should not happen with valid surrogates, but handle it
                                                            return ParseOk("\uFFFD", after_second)
                                                        }
                                                    }
                                                } else {
                                                    // Second escape is not a low surrogate - lone high surrogate
                                                    // Don't consume the second escape, let it be parsed separately
                                                    return ParseOk("\uFFFD", after_first)
                                                }
                                            }
                                        }
                                    } else {
                                        // Backslash not followed by 'u' - lone high surrogate
                                        return ParseOk("\uFFFD", after_first)
                                    }
                                }
                            }
                        } else {
                            // Not followed by backslash - lone high surrogate
                            return ParseOk("\uFFFD", after_first)
                        }
                    }
                }
            } else if is_low_surrogate(code_point) {
                // Lone low surrogate (not preceded by high) - use replacement character
                return ParseOk("\uFFFD", after_first)
            } else {
                // Regular BMP character
                match std.char.from_i32(code_point) {
                    Some(ch) => {
                        let b: StringBuilder = std.builder.new()
                        let b2: StringBuilder = std.builder.append_char(b, ch)
                        return ParseOk(std.builder.build(b2), after_first)
                    }
                    None => {
                        // Invalid Unicode code point, use replacement character
                        return ParseOk("\uFFFD", after_first)
                    }
                }
            }
        }
    }
}

// =============================================================================
// Parser - List Utilities
// =============================================================================

/// Reverses a list.
let list_reverse[T]: fn(List[T]) -> List[T] = fn(list: List[T]) -> List[T] {
    return list_reverse_acc[T](list, Nil)
}

/// Reverses a list with an accumulator.
let list_reverse_acc[T]: fn(List[T], List[T]) -> List[T] = fn(list: List[T], acc: List[T]) -> List[T] {
    match list {
        Nil => { return acc }
        Cons(head, tail) => { return list_reverse_acc[T](tail, Cons(head, acc)) }
    }
}

/// Checks if a key already exists in a list of JSON fields.
let list_has_key: fn(List[JsonField], string) -> bool = fn(fields: List[JsonField], key: string) -> bool {
    match fields {
        Nil => { return false }
        Cons(field, rest) => {
            if std.string.equals(field.key, key) {
                return true
            }
            return list_has_key(rest, key)
        }
    }
}

// =============================================================================
// Parser - Compound Parsers
// =============================================================================

/// Parses a JSON array.
let parse_array: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    match peek_str(state) {
        Some(c) => {
            if std.string.equals(c, "[") {
                // Check depth limit before entering array
                match increment_depth(state) {
                    None => {
                        return ParseErr(MaxDepthExceeded {
                            depth: state.depth + 1,
                            max_depth: state.max_depth,
                            line: state.line,
                            col: state.column
                        })
                    }
                    Some(deeper_state) => {
                        let after_bracket: ParserState = skip_whitespace(advance(deeper_state))
                        match peek_str(after_bracket) {
                            Some(c2) => {
                                if std.string.equals(c2, "]") {
                                    return ParseOk(JArray(Nil), decrement_depth(advance(after_bracket)))
                                }
                                let result: ParseResult[Json] = parse_array_elements(after_bracket, Nil)
                                // Decrement depth on successful exit
                                match result {
                                    ParseOk(json, final_state) => {
                                        return ParseOk(json, decrement_depth(final_state))
                                    }
                                    ParseErr(e) => { return ParseErr(e) }
                                }
                            }
                            None => {
                                let result: ParseResult[Json] = parse_array_elements(after_bracket, Nil)
                                match result {
                                    ParseOk(json, final_state) => {
                                        return ParseOk(json, decrement_depth(final_state))
                                    }
                                    ParseErr(e) => { return ParseErr(e) }
                                }
                            }
                        }
                    }
                }
            }
            return ParseErr(UnexpectedToken { expected: "'['", found: c, line: state.line, col: state.column })
        }
        None => { return ParseErr(UnexpectedEof { expected: "'['", context: "array", line: state.line, col: state.column }) }
    }
}

/// Parses array elements.
let parse_array_elements: fn(ParserState, List[Json]) -> ParseResult[Json] =
    fn(state: ParserState, acc: List[Json]) -> ParseResult[Json] {
        let value_result: ParseResult[Json] = parse_value(state)
        match value_result {
            ParseErr(e) => { return ParseErr(e) }
            ParseOk(value, after_value) => {
                let new_acc: List[Json] = Cons(value, acc)
                let after_ws: ParserState = skip_whitespace(after_value)
                match peek_str(after_ws) {
                    Some(c) => {
                        if std.string.equals(c, "]") {
                            return ParseOk(JArray(list_reverse[Json](new_acc)), advance(after_ws))
                        }
                        if std.string.equals(c, ",") {
                            let after_comma: ParserState = skip_whitespace(advance(after_ws))
                            return parse_array_elements(after_comma, new_acc)
                        }
                        return ParseErr(UnexpectedToken { expected: "',' or ']'", found: c, line: after_ws.line, col: after_ws.column })
                    }
                    None => { return ParseErr(UnexpectedEof { expected: "',' or ']'", context: "array", line: after_ws.line, col: after_ws.column }) }
                }
            }
        }
    }

/// Parses a JSON object.
let parse_object: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    match peek_str(state) {
        Some(c) => {
            if std.string.equals(c, "{") {
                // Check depth limit before entering object
                match increment_depth(state) {
                    None => {
                        return ParseErr(MaxDepthExceeded {
                            depth: state.depth + 1,
                            max_depth: state.max_depth,
                            line: state.line,
                            col: state.column
                        })
                    }
                    Some(deeper_state) => {
                        let after_brace: ParserState = skip_whitespace(advance(deeper_state))
                        match peek_str(after_brace) {
                            Some(c2) => {
                                if std.string.equals(c2, "}") {
                                    return ParseOk(JObject(std.map.new()), decrement_depth(advance(after_brace)))
                                }
                                let result: ParseResult[Json] = parse_object_fields_map(after_brace, std.map.new())
                                // Decrement depth on successful exit
                                match result {
                                    ParseOk(json, final_state) => {
                                        return ParseOk(json, decrement_depth(final_state))
                                    }
                                    ParseErr(e) => { return ParseErr(e) }
                                }
                            }
                            None => {
                                let result: ParseResult[Json] = parse_object_fields_map(after_brace, std.map.new())
                                match result {
                                    ParseOk(json, final_state) => {
                                        return ParseOk(json, decrement_depth(final_state))
                                    }
                                    ParseErr(e) => { return ParseErr(e) }
                                }
                            }
                        }
                    }
                }
            }
            return ParseErr(UnexpectedToken { expected: "'{'", found: c, line: state.line, col: state.column })
        }
        None => { return ParseErr(UnexpectedEof { expected: "'{'", context: "object", line: state.line, col: state.column }) }
    }
}

/// Parses object fields into a HashMap.
let parse_object_fields_map: fn(ParserState, HashMap) -> ParseResult[Json] =
    fn(state: ParserState, acc: HashMap) -> ParseResult[Json] {
        // Parse key (save position for error reporting)
        let key_line: i32 = state.line
        let key_col: i32 = state.column
        let key_result: ParseResult[string] = parse_string(state)
        match key_result {
            ParseErr(e) => { return ParseErr(e) }
            ParseOk(key, after_key) => {
                // Check for duplicate key in strict mode
                if after_key.strict {
                    if std.map.contains(acc, key) {
                        return ParseErr(DuplicateKey { key: key, line: key_line, col: key_col })
                    }
                }
                let after_key_ws: ParserState = skip_whitespace(after_key)
                // Expect colon
                match peek_str(after_key_ws) {
                    Some(c) => {
                        if std.string.equals(c, ":") {
                            let after_colon: ParserState = skip_whitespace(advance(after_key_ws))
                            // Parse value
                            let value_result: ParseResult[Json] = parse_value(after_colon)
                            match value_result {
                                ParseErr(e) => { return ParseErr(e) }
                                ParseOk(value, after_value) => {
                                    // First-wins: only add if key doesn't already exist
                                    var new_acc: HashMap = acc
                                    if not std.map.contains(acc, key) {
                                        new_acc = std.map.put(acc, key, value)
                                    }
                                    let after_ws: ParserState = skip_whitespace(after_value)
                                    match peek_str(after_ws) {
                                        Some(c2) => {
                                            if std.string.equals(c2, "}") {
                                                return ParseOk(JObject(new_acc), advance(after_ws))
                                            }
                                            if std.string.equals(c2, ",") {
                                                let after_comma: ParserState = skip_whitespace(advance(after_ws))
                                                return parse_object_fields_map(after_comma, new_acc)
                                            }
                                            return ParseErr(UnexpectedToken { expected: "',' or '}'", found: c2, line: after_ws.line, col: after_ws.column })
                                        }
                                        None => { return ParseErr(UnexpectedEof { expected: "',' or '}'", context: "object", line: after_ws.line, col: after_ws.column }) }
                                    }
                                }
                            }
                        }
                        return ParseErr(UnexpectedToken { expected: "':'", found: c, line: after_key_ws.line, col: after_key_ws.column })
                    }
                    None => { return ParseErr(UnexpectedEof { expected: "':'", context: "object field", line: after_key_ws.line, col: after_key_ws.column }) }
                }
            }
        }
    }

/// Parses object fields (List[JsonField] version).
/// Retained for backward compatibility.
let parse_object_fields: fn(ParserState, List[JsonField]) -> ParseResult[Json] =
    fn(state: ParserState, acc: List[JsonField]) -> ParseResult[Json] {
        // Parse key (save position for error reporting)
        let key_line: i32 = state.line
        let key_col: i32 = state.column
        let key_result: ParseResult[string] = parse_string(state)
        match key_result {
            ParseErr(e) => { return ParseErr(e) }
            ParseOk(key, after_key) => {
                // Check for duplicate key in strict mode
                if after_key.strict {
                    if list_has_key(acc, key) {
                        return ParseErr(DuplicateKey { key: key, line: key_line, col: key_col })
                    }
                }
                let after_key_ws: ParserState = skip_whitespace(after_key)
                // Expect colon
                match peek_str(after_key_ws) {
                    Some(c) => {
                        if std.string.equals(c, ":") {
                            let after_colon: ParserState = skip_whitespace(advance(after_key_ws))
                            // Parse value
                            let value_result: ParseResult[Json] = parse_value(after_colon)
                            match value_result {
                                ParseErr(e) => { return ParseErr(e) }
                                ParseOk(value, after_value) => {
                                    let field: JsonField = JsonField { key: key, value: value }
                                    let new_acc: List[JsonField] = Cons(field, acc)
                                    let after_ws: ParserState = skip_whitespace(after_value)
                                    match peek_str(after_ws) {
                                        Some(c2) => {
                                            if std.string.equals(c2, "}") {
                                                return ParseOk(JObject(fields_to_hashmap(list_reverse[JsonField](new_acc))), advance(after_ws))
                                            }
                                            if std.string.equals(c2, ",") {
                                                let after_comma: ParserState = skip_whitespace(advance(after_ws))
                                                return parse_object_fields(after_comma, new_acc)
                                            }
                                            return ParseErr(UnexpectedToken { expected: "',' or '}'", found: c2, line: after_ws.line, col: after_ws.column })
                                        }
                                        None => { return ParseErr(UnexpectedEof { expected: "',' or '}'", context: "object", line: after_ws.line, col: after_ws.column }) }
                                    }
                                }
                            }
                        }
                        return ParseErr(UnexpectedToken { expected: "':'", found: c, line: after_key_ws.line, col: after_key_ws.column })
                    }
                    None => { return ParseErr(UnexpectedEof { expected: "':'", context: "object field", line: after_key_ws.line, col: after_key_ws.column }) }
                }
            }
        }
    }

// =============================================================================
// Parser - Main Parse Dispatch
// =============================================================================

/// Parses a JSON value based on the first character.
let parse_value: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    let ws_state: ParserState = skip_whitespace(state)
    match peek_str(ws_state) {
        None => { return ParseErr(UnexpectedEof { expected: "JSON value", context: "value", line: ws_state.line, col: ws_state.column }) }
        Some(c) => {
            if std.string.equals(c, "n") {
                return parse_null(ws_state)
            }
            if std.string.equals(c, "t") or std.string.equals(c, "f") {
                return parse_bool(ws_state)
            }
            if std.string.equals(c, "\"") {
                let str_result: ParseResult[string] = parse_string(ws_state)
                match str_result {
                    ParseOk(s, new_state) => { return ParseOk(JString(s), new_state) }
                    ParseErr(e) => { return ParseErr(e) }
                }
            }
            if std.string.equals(c, "[") {
                return parse_array(ws_state)
            }
            if std.string.equals(c, "{") {
                return parse_object(ws_state)
            }
            if std.string.equals(c, "-") or is_digit_str(c) {
                return parse_number(ws_state)
            }
            return ParseErr(UnexpectedToken { expected: "JSON value", found: c, line: ws_state.line, col: ws_state.column })
        }
    }
}

/// Parses a JSON string with a custom maximum nesting depth.
/// Use this to limit memory usage for untrusted input or allow deeper nesting if needed.
/// Set max_depth to 0 for unlimited depth (not recommended for untrusted input).
pub let parse_with_max_depth: fn(string, i32) -> Result[Json, JsonError] = fn(input: string, max_depth: i32) -> Result[Json, JsonError] {
    var effective_max: i32 = max_depth
    if max_depth <= 0 {
        effective_max = 2147483647
    }
    let state: ParserState = init_state_with_depth(input, effective_max)
    let result: ParseResult[Json] = parse_value(state)
    match result {
        ParseOk(json, final_state) => {
            let after_ws: ParserState = skip_whitespace(final_state)
            if is_eof(after_ws) {
                return Ok(json)
            }
            match peek_str(after_ws) {
                Some(c) => { return Err(TrailingContent { found: c, line: after_ws.line, col: after_ws.column }) }
                None => { return Ok(json) }
            }
        }
        ParseErr(e) => { return Err(e) }
    }
}

/// Public API: Parses a JSON string into a Json value.
/// Uses the default maximum nesting depth (512 levels).
pub let parse: fn(string) -> Result[Json, JsonError] = fn(input: string) -> Result[Json, JsonError] {
    return parse_with_max_depth(input, default_max_depth())
}

/// Internal: Parses a JSON string with custom options.
let parse_internal: fn(string, i32, bool) -> Result[Json, JsonError] = fn(input: string, max_depth: i32, strict: bool) -> Result[Json, JsonError] {
    var effective_max: i32 = max_depth
    if max_depth <= 0 {
        effective_max = 2147483647
    }
    let state: ParserState = init_state_strict(input, effective_max, strict)
    let result: ParseResult[Json] = parse_value(state)
    match result {
        ParseOk(json, final_state) => {
            let after_ws: ParserState = skip_whitespace(final_state)
            if is_eof(after_ws) {
                return Ok(json)
            }
            match peek_str(after_ws) {
                Some(c) => { return Err(TrailingContent { found: c, line: after_ws.line, col: after_ws.column }) }
                None => { return Ok(json) }
            }
        }
        ParseErr(e) => { return Err(e) }
    }
}

/// Parses a JSON string in strict mode with a custom maximum nesting depth.
/// Strict mode rejects duplicate keys in objects with a DuplicateKey error.
/// Use this for applications that require RFC 8259 strict compliance.
pub let parse_strict_with_max_depth: fn(string, i32) -> Result[Json, JsonError] = fn(input: string, max_depth: i32) -> Result[Json, JsonError] {
    return parse_internal(input, max_depth, true)
}

/// Parses a JSON string in strict mode.
/// Strict mode rejects duplicate keys in objects with a DuplicateKey error.
/// Uses the default maximum nesting depth (512 levels).
pub let parse_strict: fn(string) -> Result[Json, JsonError] = fn(input: string) -> Result[Json, JsonError] {
    return parse_strict_with_max_depth(input, default_max_depth())
}

// =============================================================================
// Transformers - Value Mapping
// =============================================================================

/// Recursively applies a function to all JSON values.
pub let map_values: fn(Json, fn(Json) -> Json) -> Json = fn(json: Json, f: fn(Json) -> Json) -> Json {
    let mapped: Json = f(json)
    match mapped {
        JArray(arr) => {
            return JArray(map_list[Json](arr, fn(elem: Json) -> Json { return map_values(elem, f) }))
        }
        JObject(map) => {
            let entries: List[(string, Json)] = std.map.entries(map)
            let mapped_entries: List[(string, Json)] = map_entries_values(entries, f)
            return JObject(entries_to_hashmap(mapped_entries))
        }
        _ => { return mapped }
    }
}

/// Maps a function over entry values.
let map_entries_values: fn(List[(string, Json)], fn(Json) -> Json) -> List[(string, Json)] =
    fn(entries: List[(string, Json)], f: fn(Json) -> Json) -> List[(string, Json)] {
        match entries {
            Nil => { return Nil }
            Cons(entry, rest) => {
                let new_entry: (string, Json) = (entry.0, map_values(entry.1, f))
                return Cons(new_entry, map_entries_values(rest, f))
            }
        }
    }

/// Converts a list of (string, Json) tuples to a HashMap.
let entries_to_hashmap: fn(List[(string, Json)]) -> HashMap = fn(entries: List[(string, Json)]) -> HashMap {
    return entries_to_hashmap_acc(entries, std.map.new())
}

/// Helper to convert entries to HashMap with accumulator.
let entries_to_hashmap_acc: fn(List[(string, Json)], HashMap) -> HashMap =
    fn(entries: List[(string, Json)], acc: HashMap) -> HashMap {
        match entries {
            Nil => { return acc }
            Cons(entry, rest) => {
                let new_acc: HashMap = std.map.put(acc, entry.0, entry.1)
                return entries_to_hashmap_acc(rest, new_acc)
            }
        }
    }

/// Maps a function over a list.
let map_list[A]: fn(List[A], fn(A) -> A) -> List[A] = fn(list: List[A], f: fn(A) -> A) -> List[A] {
    match list {
        Nil => { return Nil }
        Cons(head, tail) => { return Cons(f(head), map_list[A](tail, f)) }
    }
}

// =============================================================================
// Transformers - Field Filtering
// =============================================================================

/// Filters object fields at the top level.
pub let filter_fields: fn(Json, fn(string, Json) -> bool) -> Json =
    fn(json: Json, pred: fn(string, Json) -> bool) -> Json {
        match json {
            JObject(map) => {
                let entries: List[(string, Json)] = std.map.entries(map)
                let filtered: List[(string, Json)] = filter_entries(entries, pred)
                return JObject(entries_to_hashmap(filtered))
            }
            _ => { return json }
        }
    }

/// Recursively filters object fields at all levels.
pub let filter_fields_deep: fn(Json, fn(string, Json) -> bool) -> Json =
    fn(json: Json, pred: fn(string, Json) -> bool) -> Json {
        match json {
            JArray(arr) => {
                return JArray(map_list[Json](arr, fn(elem: Json) -> Json {
                    return filter_fields_deep(elem, pred)
                }))
            }
            JObject(map) => {
                let entries: List[(string, Json)] = std.map.entries(map)
                let filtered: List[(string, Json)] = filter_entries(entries, pred)
                let deep_filtered: List[(string, Json)] = map_list_entry(filtered, fn(entry: (string, Json)) -> (string, Json) {
                    return (entry.0, filter_fields_deep(entry.1, pred))
                })
                return JObject(entries_to_hashmap(deep_filtered))
            }
            _ => { return json }
        }
    }

/// Filters entries based on a predicate.
let filter_entries: fn(List[(string, Json)], fn(string, Json) -> bool) -> List[(string, Json)] =
    fn(entries: List[(string, Json)], pred: fn(string, Json) -> bool) -> List[(string, Json)] {
        match entries {
            Nil => { return Nil }
            Cons(entry, rest) => {
                if pred(entry.0, entry.1) {
                    return Cons(entry, filter_entries(rest, pred))
                }
                return filter_entries(rest, pred)
            }
        }
    }

/// Maps a function over entries (different type signature than map_list).
let map_list_entry: fn(List[(string, Json)], fn((string, Json)) -> (string, Json)) -> List[(string, Json)] =
    fn(entries: List[(string, Json)], f: fn((string, Json)) -> (string, Json)) -> List[(string, Json)] {
        match entries {
            Nil => { return Nil }
            Cons(entry, rest) => { return Cons(f(entry), map_list_entry(rest, f)) }
        }
    }

/// Filters a list of JsonFields based on a predicate.
let filter_fields_list: fn(List[JsonField], fn(string, Json) -> bool) -> List[JsonField] =
    fn(fields: List[JsonField], pred: fn(string, Json) -> bool) -> List[JsonField] {
        match fields {
            Nil => { return Nil }
            Cons(field, rest) => {
                if pred(field.key, field.value) {
                    return Cons(field, filter_fields_list(rest, pred))
                }
                return filter_fields_list(rest, pred)
            }
        }
    }

// =============================================================================
// Transformers - Object Operations
// =============================================================================

/// Sets a field in a JSON object. If the key exists, updates it; otherwise adds it.
/// Uses O(1) HashMap put operation.
pub let set_field: fn(Json, string, Json) -> Json = fn(json: Json, key: string, value: Json) -> Json {
    match json {
        JObject(map) => {
            let updated: HashMap = std.map.put(map, key, value)
            return JObject(updated)
        }
        _ => { return json }
    }
}

/// Helper to set a field in a list of JsonFields.
/// Retained for backward compatibility.
let set_field_in_list: fn(List[JsonField], string, Json, bool) -> List[JsonField] =
    fn(fields: List[JsonField], key: string, value: Json, found: bool) -> List[JsonField] {
        match fields {
            Nil => {
                if found {
                    return Nil
                }
                // Key not found, append new field
                return Cons(JsonField { key: key, value: value }, Nil)
            }
            Cons(field, rest) => {
                if std.string.equals(field.key, key) {
                    // Found the key, update it
                    return Cons(JsonField { key: key, value: value }, set_field_in_list(rest, key, value, true))
                }
                return Cons(field, set_field_in_list(rest, key, value, found))
            }
        }
    }

/// Removes a field from a JSON object.
/// Uses O(1) HashMap remove operation.
pub let remove_field: fn(Json, string) -> Json = fn(json: Json, key: string) -> Json {
    match json {
        JObject(map) => {
            let filtered: HashMap = std.map.remove(map, key)
            return JObject(filtered)
        }
        _ => { return json }
    }
}

/// Helper to remove a field from a list of JsonFields.
/// Retained for backward compatibility.
let remove_field_from_list: fn(List[JsonField], string) -> List[JsonField] =
    fn(fields: List[JsonField], key: string) -> List[JsonField] {
        match fields {
            Nil => { return Nil }
            Cons(field, rest) => {
                if std.string.equals(field.key, key) {
                    return remove_field_from_list(rest, key)
                }
                return Cons(field, remove_field_from_list(rest, key))
            }
        }
    }

// =============================================================================
// Transformers - Merge Operations
// =============================================================================

/// Shallow merges two JSON values. For objects, b's fields override a's.
pub let merge: fn(Json, Json) -> Json = fn(a: Json, b: Json) -> Json {
    match (a, b) {
        (JObject(map_a), JObject(map_b)) => {
            let merged: HashMap = merge_hashmaps(map_a, map_b)
            return JObject(merged)
        }
        _ => { return b }
    }
}

/// Merges two HashMaps, with the second map's fields taking precedence.
let merge_hashmaps: fn(HashMap, HashMap) -> HashMap = fn(map_a: HashMap, map_b: HashMap) -> HashMap {
    // Start with all entries from a
    let entries_a: List[(string, Json)] = std.map.entries(map_a)
    let entries_b: List[(string, Json)] = std.map.entries(map_b)
    // Add entries from b, overwriting any from a
    let base: HashMap = entries_to_hashmap(entries_a)
    return merge_entries_into(base, entries_b)
}

/// Merges entries into a HashMap.
let merge_entries_into: fn(HashMap, List[(string, Json)]) -> HashMap =
    fn(map: HashMap, entries: List[(string, Json)]) -> HashMap {
        match entries {
            Nil => { return map }
            Cons(entry, rest) => {
                let new_map: HashMap = std.map.put(map, entry.0, entry.1)
                return merge_entries_into(new_map, rest)
            }
        }
    }

/// Merges two field lists, with the second list's fields taking precedence.
/// Retained for backward compatibility.
let merge_fields: fn(List[JsonField], List[JsonField]) -> List[JsonField] =
    fn(fields_a: List[JsonField], fields_b: List[JsonField]) -> List[JsonField] {
        // Start with fields from a that are not in b, then add all of b
        let a_only: List[JsonField] = filter_fields_not_in(fields_a, fields_b)
        return list_concat[JsonField](a_only, fields_b)
    }

/// Filters fields from the first list that are not present in the second list.
let filter_fields_not_in: fn(List[JsonField], List[JsonField]) -> List[JsonField] =
    fn(fields: List[JsonField], exclude: List[JsonField]) -> List[JsonField] {
        match fields {
            Nil => { return Nil }
            Cons(field, rest) => {
                if has_key(exclude, field.key) {
                    return filter_fields_not_in(rest, exclude)
                }
                return Cons(field, filter_fields_not_in(rest, exclude))
            }
        }
    }

/// Checks if a field list contains a key.
let has_key: fn(List[JsonField], string) -> bool = fn(fields: List[JsonField], key: string) -> bool {
    match fields {
        Nil => { return false }
        Cons(field, rest) => {
            if std.string.equals(field.key, key) {
                return true
            }
            return has_key(rest, key)
        }
    }
}

/// Concatenates two lists.
let list_concat[T]: fn(List[T], List[T]) -> List[T] = fn(a: List[T], b: List[T]) -> List[T] {
    match a {
        Nil => { return b }
        Cons(head, tail) => { return Cons(head, list_concat[T](tail, b)) }
    }
}

/// Deep merges two JSON values. For objects, recursively merges nested objects.
pub let merge_deep: fn(Json, Json) -> Json = fn(a: Json, b: Json) -> Json {
    match (a, b) {
        (JObject(map_a), JObject(map_b)) => {
            let merged: HashMap = merge_hashmaps_deep(map_a, map_b)
            return JObject(merged)
        }
        _ => { return b }
    }
}

/// Deep merges two HashMaps.
let merge_hashmaps_deep: fn(HashMap, HashMap) -> HashMap = fn(map_a: HashMap, map_b: HashMap) -> HashMap {
    let entries_a: List[(string, Json)] = std.map.entries(map_a)
    let entries_b: List[(string, Json)] = std.map.entries(map_b)

    // Process entries from a, merging with b if key exists in both
    let a_processed: List[(string, Json)] = map_list_entry(entries_a, fn(entry_a: (string, Json)) -> (string, Json) {
        match std.map.get(map_b, entry_a.0) {
            Some(value_b) => {
                return (entry_a.0, merge_deep(entry_a.1, value_b))
            }
            None => { return entry_a }
        }
    })

    // Get entries from b that are not in a
    let b_only: List[(string, Json)] = filter_entries_not_in_map(entries_b, map_a)

    // Combine processed a entries with b-only entries
    let combined: List[(string, Json)] = list_concat_entries(a_processed, b_only)
    return entries_to_hashmap(combined)
}

/// Filters entries not present in a HashMap.
let filter_entries_not_in_map: fn(List[(string, Json)], HashMap) -> List[(string, Json)] =
    fn(entries: List[(string, Json)], map: HashMap) -> List[(string, Json)] {
        match entries {
            Nil => { return Nil }
            Cons(entry, rest) => {
                if std.map.contains(map, entry.0) {
                    return filter_entries_not_in_map(rest, map)
                }
                return Cons(entry, filter_entries_not_in_map(rest, map))
            }
        }
    }

/// Concatenates two entry lists.
let list_concat_entries: fn(List[(string, Json)], List[(string, Json)]) -> List[(string, Json)] =
    fn(a: List[(string, Json)], b: List[(string, Json)]) -> List[(string, Json)] {
        match a {
            Nil => { return b }
            Cons(head, tail) => { return Cons(head, list_concat_entries(tail, b)) }
        }
    }

/// Deep merges two field lists.
/// Retained for backward compatibility.
let merge_fields_deep: fn(List[JsonField], List[JsonField]) -> List[JsonField] =
    fn(fields_a: List[JsonField], fields_b: List[JsonField]) -> List[JsonField] {
        let a_processed: List[JsonField] = map_list[JsonField](fields_a, fn(field_a: JsonField) -> JsonField {
            match find_field(fields_b, field_a.key) {
                Some(value_b) => {
                    return JsonField { key: field_a.key, value: merge_deep(field_a.value, value_b) }
                }
                None => { return field_a }
            }
        })
        let b_only: List[JsonField] = filter_fields_not_in(fields_b, fields_a)
        return list_concat[JsonField](a_processed, b_only)
    }

// =============================================================================
// Transformers - Array Operations
// =============================================================================

/// Maps a function over a JSON array's elements.
pub let map_array: fn(Json, fn(Json) -> Json) -> Json = fn(json: Json, f: fn(Json) -> Json) -> Json {
    match json {
        JArray(arr) => {
            return JArray(map_list[Json](arr, f))
        }
        _ => { return json }
    }
}

/// Filters a JSON array's elements based on a predicate.
pub let filter_array: fn(Json, fn(Json) -> bool) -> Json = fn(json: Json, pred: fn(Json) -> bool) -> Json {
    match json {
        JArray(arr) => {
            return JArray(filter_list[Json](arr, pred))
        }
        _ => { return json }
    }
}

/// Filters a list based on a predicate.
let filter_list[T]: fn(List[T], fn(T) -> bool) -> List[T] = fn(list: List[T], pred: fn(T) -> bool) -> List[T] {
    match list {
        Nil => { return Nil }
        Cons(head, tail) => {
            if pred(head) {
                return Cons(head, filter_list[T](tail, pred))
            }
            return filter_list[T](tail, pred)
        }
    }
}

// =============================================================================
// Equality - Deep Structural Comparison
// =============================================================================

/// Compares two JSON values for deep structural equality.
/// Objects are compared by key-value pairs, independent of key order.
/// Numbers are compared with tolerance for floating point precision issues.
pub let equals: fn(Json, Json) -> bool = fn(a: Json, b: Json) -> bool {
    match (a, b) {
        (JNull, JNull) => { return true }
        (JBool(a_val), JBool(b_val)) => { return a_val == b_val }
        (JNumber(a_val), JNumber(b_val)) => { return numbers_equal(a_val, b_val) }
        (JString(a_val), JString(b_val)) => { return std.string.equals(a_val, b_val) }
        (JArray(a_arr), JArray(b_arr)) => { return arrays_equal(a_arr, b_arr) }
        (JObject(a_map), JObject(b_map)) => { return objects_equal_map(a_map, b_map) }
        _ => { return false }
    }
}

/// Compares two floating-point numbers for equality.
/// Uses exact comparison for integers and special values, with relative tolerance for decimals.
let numbers_equal: fn(f64, f64) -> bool = fn(a: f64, b: f64) -> bool {
    // Handle exact equality first (includes both being the same infinity)
    if a == b {
        return true
    }

    // Handle NaN - NaN != NaN in IEEE 754, but for JSON equality we consider them equal
    if std.float.is_nan(a) and std.float.is_nan(b) {
        return true
    }

    // Handle infinity cases - if one is infinite and they're not equal, they differ
    if std.float.is_infinite(a) or std.float.is_infinite(b) {
        return false
    }

    // For finite numbers, use relative epsilon comparison
    // This handles floating point precision issues for parsed numbers
    let diff: f64 = std.float.abs(a - b)
    let max_val: f64 = std.float.max(std.float.abs(a), std.float.abs(b))

    // Use relative epsilon relative to the larger magnitude
    // For very small numbers close to zero, use absolute epsilon
    let small_threshold: f64 = 0.0000000001  // 1e-10
    let abs_epsilon: f64 = 0.000000000000001  // 1e-15
    let rel_epsilon: f64 = 0.00000000000001   // 1e-14

    if max_val < small_threshold {
        return diff < abs_epsilon
    }
    return diff < max_val * rel_epsilon
}

/// Compares two JSON arrays for equality (order-dependent).
let arrays_equal: fn(List[Json], List[Json]) -> bool = fn(a: List[Json], b: List[Json]) -> bool {
    match (a, b) {
        (Nil, Nil) => { return true }
        (Cons(a_head, a_tail), Cons(b_head, b_tail)) => {
            if equals(a_head, b_head) {
                return arrays_equal(a_tail, b_tail)
            }
            return false
        }
        _ => { return false }
    }
}

/// Compares two JSON objects for equality (key-order independent).
/// Two objects are equal if they have the same keys with equal values.
let objects_equal_map: fn(HashMap, HashMap) -> bool =
    fn(a_map: HashMap, b_map: HashMap) -> bool {
        // First check if they have the same number of fields
        if std.map.size(a_map) != std.map.size(b_map) {
            return false
        }

        // Check that every field in 'a' exists in 'b' with equal value
        let entries_a: List[(string, Json)] = std.map.entries(a_map)
        return all_entries_match(entries_a, b_map)
    }

/// Checks if all entries in the list have matching values in the HashMap.
let all_entries_match: fn(List[(string, Json)], HashMap) -> bool =
    fn(entries: List[(string, Json)], b_map: HashMap) -> bool {
        match entries {
            Nil => { return true }
            Cons(entry, rest) => {
                match std.map.get(b_map, entry.0) {
                    Some(b_value) => {
                        if equals(entry.1, b_value) {
                            return all_entries_match(rest, b_map)
                        }
                        return false
                    }
                    None => { return false }
                }
            }
        }
    }

/// Compares two JSON objects for equality (key-order independent).
/// Retained for backward compatibility.
let objects_equal: fn(List[JsonField], List[JsonField]) -> bool =
    fn(a_fields: List[JsonField], b_fields: List[JsonField]) -> bool {
        // First check if they have the same number of fields
        if list_length[JsonField](a_fields) != list_length[JsonField](b_fields) {
            return false
        }

        // Check that every field in 'a' exists in 'b' with equal value
        return all_fields_match(a_fields, b_fields)
    }

/// Checks if all fields in the first list have matching values in the second list.
let all_fields_match: fn(List[JsonField], List[JsonField]) -> bool =
    fn(a_fields: List[JsonField], b_fields: List[JsonField]) -> bool {
        match a_fields {
            Nil => { return true }
            Cons(a_field, rest) => {
                match find_field(b_fields, a_field.key) {
                    Some(b_value) => {
                        if equals(a_field.value, b_value) {
                            return all_fields_match(rest, b_fields)
                        }
                        return false
                    }
                    None => { return false }
                }
            }
        }
    }

// =============================================================================
// Path-Based Access
// =============================================================================

/// Represents a single segment in a JSON path.
/// A path like "users[0].name" has segments: Key("users"), Index(0), Key("name")
type PathSegment =
    | PathKey(string)
    | PathIndex(i32)

/// Error type for path parsing failures.
pub type PathError =
    | EmptyPath
    | InvalidIndex { segment: string }
    | UnterminatedBracket { position: i32 }
    | EmptyBracket { position: i32 }
    | UnexpectedChar { char: string, position: i32 }

/// Formats a PathError to a human-readable string.
pub let format_path_error: fn(PathError) -> string = fn(err: PathError) -> string {
    match err {
        EmptyPath => { return "Path cannot be empty" }
        InvalidIndex { segment: seg } => {
            return std.string.concat("Invalid array index: ", seg)
        }
        UnterminatedBracket { position: pos } => {
            return std.string.concat("Unterminated bracket at position ", std.int.to_string(pos))
        }
        EmptyBracket { position: pos } => {
            return std.string.concat("Empty bracket at position ", std.int.to_string(pos))
        }
        UnexpectedChar { char: c, position: pos } => {
            return std.string.concat("Unexpected character '", std.string.concat(c, std.string.concat("' at position ", std.int.to_string(pos))))
        }
    }
}

/// Gets a value at the given path.
/// Path format: "field.nested[0].key" - dots separate object keys, [n] for array indices.
/// Returns None if the path doesn't exist or if any intermediate value is not the expected type.
pub let get_path: fn(Json, string) -> Option[Json] = fn(json: Json, path: string) -> Option[Json] {
    if std.string.length(path) == 0 {
        return Some(json)
    }
    let segments_result: Result[List[PathSegment], PathError] = parse_path(path)
    match segments_result {
        Err(_) => { return None }
        Ok(segments) => { return get_path_segments(json, segments) }
    }
}

/// Parses a path and returns any parsing errors.
/// Useful when you want to validate a path before using it.
pub let parse_path: fn(string) -> Result[List[PathSegment], PathError] = fn(path: string) -> Result[List[PathSegment], PathError] {
    if std.string.length(path) == 0 {
        return Ok(Nil)
    }
    return parse_path_from(path, 0, std.string.length(path))
}

/// Internal path parser starting from a given position.
let parse_path_from: fn(string, i32, i32) -> Result[List[PathSegment], PathError] =
    fn(path: string, pos: i32, len: i32) -> Result[List[PathSegment], PathError] {
        if pos >= len {
            return Ok(Nil)
        }

        let c: string = std.string.substring(path, pos, pos + 1)

        // Skip leading dot (except at start)
        if std.string.equals(c, ".") {
            return parse_path_from(path, pos + 1, len)
        }

        // Parse array index: [n]
        if std.string.equals(c, "[") {
            return parse_index_segment(path, pos + 1, len)
        }

        // Parse key segment
        return parse_key_segment(path, pos, len)
    }

/// Parses a key segment until a dot or bracket.
let parse_key_segment: fn(string, i32, i32) -> Result[List[PathSegment], PathError] =
    fn(path: string, start: i32, len: i32) -> Result[List[PathSegment], PathError] {
        let end: i32 = find_key_end(path, start, len)
        if end == start {
            // Empty key at start could mean we hit a special char
            let c: string = std.string.substring(path, start, start + 1)
            return Err(UnexpectedChar { char: c, position: start })
        }
        let key: string = std.string.substring(path, start, end)
        let rest_result: Result[List[PathSegment], PathError] = parse_path_from(path, end, len)
        match rest_result {
            Err(e) => { return Err(e) }
            Ok(rest) => { return Ok(Cons(PathKey(key), rest)) }
        }
    }

/// Finds the end of a key (position of next dot, bracket, or end of string).
let find_key_end: fn(string, i32, i32) -> i32 = fn(path: string, pos: i32, len: i32) -> i32 {
    if pos >= len {
        return pos
    }
    let c: string = std.string.substring(path, pos, pos + 1)
    if std.string.equals(c, ".") or std.string.equals(c, "[") {
        return pos
    }
    return find_key_end(path, pos + 1, len)
}

/// Parses an index segment [n].
let parse_index_segment: fn(string, i32, i32) -> Result[List[PathSegment], PathError] =
    fn(path: string, start: i32, len: i32) -> Result[List[PathSegment], PathError] {
        let bracket_end: i32 = find_char(path, "]", start, len)
        if bracket_end < 0 {
            return Err(UnterminatedBracket { position: start - 1 })
        }
        if bracket_end == start {
            return Err(EmptyBracket { position: start - 1 })
        }
        let index_str: string = std.string.substring(path, start, bracket_end)
        match parse_index_value(index_str) {
            None => { return Err(InvalidIndex { segment: index_str }) }
            Some(idx) => {
                let rest_result: Result[List[PathSegment], PathError] = parse_path_from(path, bracket_end + 1, len)
                match rest_result {
                    Err(e) => { return Err(e) }
                    Ok(rest) => { return Ok(Cons(PathIndex(idx), rest)) }
                }
            }
        }
    }

/// Finds the position of a character in a string, or -1 if not found.
let find_char: fn(string, string, i32, i32) -> i32 = fn(s: string, target: string, pos: i32, len: i32) -> i32 {
    if pos >= len {
        return -1
    }
    let c: string = std.string.substring(s, pos, pos + 1)
    if std.string.equals(c, target) {
        return pos
    }
    return find_char(s, target, pos + 1, len)
}

/// Parses a non-negative integer from a string.
let parse_index_value: fn(string) -> Option[i32] = fn(s: string) -> Option[i32] {
    let len: i32 = std.string.length(s)
    if len == 0 {
        return None
    }
    // Check if all characters are digits
    if not all_digits(s, 0, len) {
        return None
    }
    // Parse the number
    return Some(parse_int_acc(s, 0, len, 0))
}

/// Checks if all characters in the range are digits.
let all_digits: fn(string, i32, i32) -> bool = fn(s: string, pos: i32, len: i32) -> bool {
    if pos >= len {
        return true
    }
    let c: string = std.string.substring(s, pos, pos + 1)
    if not is_digit_str(c) {
        return false
    }
    return all_digits(s, pos + 1, len)
}

/// Parses an integer with accumulator.
let parse_int_acc: fn(string, i32, i32, i32) -> i32 = fn(s: string, pos: i32, len: i32, acc: i32) -> i32 {
    if pos >= len {
        return acc
    }
    let c: string = std.string.substring(s, pos, pos + 1)
    let digit: i32 = digit_value(c)
    return parse_int_acc(s, pos + 1, len, acc * 10 + digit)
}

/// Converts a digit character to its integer value.
let digit_value: fn(string) -> i32 = fn(c: string) -> i32 {
    if std.string.equals(c, "0") { return 0 }
    if std.string.equals(c, "1") { return 1 }
    if std.string.equals(c, "2") { return 2 }
    if std.string.equals(c, "3") { return 3 }
    if std.string.equals(c, "4") { return 4 }
    if std.string.equals(c, "5") { return 5 }
    if std.string.equals(c, "6") { return 6 }
    if std.string.equals(c, "7") { return 7 }
    if std.string.equals(c, "8") { return 8 }
    return 9
}

/// Navigates the JSON value using parsed path segments.
let get_path_segments: fn(Json, List[PathSegment]) -> Option[Json] =
    fn(json: Json, segments: List[PathSegment]) -> Option[Json] {
        match segments {
            Nil => { return Some(json) }
            Cons(segment, rest) => {
                let next_value: Option[Json] = apply_segment(json, segment)
                match next_value {
                    None => { return None }
                    Some(v) => { return get_path_segments(v, rest) }
                }
            }
        }
    }

/// Applies a single path segment to a JSON value.
let apply_segment: fn(Json, PathSegment) -> Option[Json] = fn(json: Json, segment: PathSegment) -> Option[Json] {
    match segment {
        PathKey(key) => { return get_field(json, key) }
        PathIndex(idx) => { return get_index(json, idx) }
    }
}

/// Sets a value at the given path, creating intermediate objects/arrays as needed.
/// Returns the modified JSON. If the path is invalid or can't be set, returns the original JSON.
pub let set_path: fn(Json, string, Json) -> Json = fn(json: Json, path: string, value: Json) -> Json {
    if std.string.length(path) == 0 {
        return value
    }
    let segments_result: Result[List[PathSegment], PathError] = parse_path(path)
    match segments_result {
        Err(_) => { return json }
        Ok(segments) => { return set_path_segments(json, segments, value) }
    }
}

/// Sets a value using parsed path segments.
let set_path_segments: fn(Json, List[PathSegment], Json) -> Json =
    fn(json: Json, segments: List[PathSegment], value: Json) -> Json {
        match segments {
            Nil => { return value }
            Cons(segment, rest) => {
                match segment {
                    PathKey(key) => {
                        // Ensure we have an object, or create one
                        var obj_map: HashMap = std.map.new()
                        match json {
                            JObject(m) => { obj_map = m }
                            _ => {}
                        }
                        // Get or create nested value
                        let nested: Json = get_or_default_for_segment_map(obj_map, key, rest)
                        let new_value: Json = set_path_segments(nested, rest, value)
                        return set_field_in_object_map(obj_map, key, new_value)
                    }
                    PathIndex(idx) => {
                        // Ensure we have an array, or create one
                        var arr: List[Json] = Nil
                        match json {
                            JArray(a) => { arr = a }
                            _ => {}
                        }
                        // Get or create nested value
                        let nested: Json = get_or_default_at_index(arr, idx, rest)
                        let new_value: Json = set_path_segments(nested, rest, value)
                        return JArray(set_at_index(arr, idx, new_value))
                    }
                }
            }
        }
    }

/// Gets the current value at a key, or creates a default based on next segment.
let get_or_default_for_segment_map: fn(HashMap, string, List[PathSegment]) -> Json =
    fn(map: HashMap, key: string, next_segments: List[PathSegment]) -> Json {
        match std.map.get(map, key) {
            Some(v) => { return v }
            None => { return default_for_next_segment(next_segments) }
        }
    }

/// Gets the current value at a key, or creates a default based on next segment.
/// Retained for backward compatibility.
let get_or_default_for_segment: fn(List[JsonField], string, List[PathSegment]) -> Json =
    fn(fields: List[JsonField], key: string, next_segments: List[PathSegment]) -> Json {
        match find_field(fields, key) {
            Some(v) => { return v }
            None => { return default_for_next_segment(next_segments) }
        }
    }

/// Gets the current value at an index, or creates a default based on next segment.
let get_or_default_at_index: fn(List[Json], i32, List[PathSegment]) -> Json =
    fn(arr: List[Json], idx: i32, next_segments: List[PathSegment]) -> Json {
        match list_get(arr, idx) {
            Some(v) => { return v }
            None => { return default_for_next_segment(next_segments) }
        }
    }

/// Returns the default value to create based on what the next segment expects.
let default_for_next_segment: fn(List[PathSegment]) -> Json = fn(segments: List[PathSegment]) -> Json {
    match segments {
        Nil => { return JNull }
        Cons(segment, _) => {
            match segment {
                PathKey(_) => { return JObject(std.map.new()) }
                PathIndex(_) => { return JArray(Nil) }
            }
        }
    }
}

/// Sets a field in an object HashMap, returning a new JObject.
let set_field_in_object_map: fn(HashMap, string, Json) -> Json =
    fn(map: HashMap, key: string, value: Json) -> Json {
        let updated: HashMap = std.map.put(map, key, value)
        return JObject(updated)
    }

/// Sets a field in an object, returning a new JObject.
/// Retained for backward compatibility.
let set_field_in_object: fn(List[JsonField], string, Json) -> Json =
    fn(fields: List[JsonField], key: string, value: Json) -> Json {
        let updated: List[JsonField] = set_field_in_list(fields, key, value, false)
        return JObject(fields_to_hashmap(updated))
    }

/// Sets a value at an index in a list, extending with JNull if needed.
let set_at_index: fn(List[Json], i32, Json) -> List[Json] =
    fn(arr: List[Json], idx: i32, value: Json) -> List[Json] {
        if idx < 0 {
            return arr
        }
        return set_at_index_impl(arr, idx, value)
    }

/// Implementation of set_at_index.
let set_at_index_impl: fn(List[Json], i32, Json) -> List[Json] =
    fn(arr: List[Json], idx: i32, value: Json) -> List[Json] {
        match arr {
            Nil => {
                if idx == 0 {
                    return Cons(value, Nil)
                }
                // Need to extend with nulls
                return Cons(JNull, set_at_index_impl(Nil, idx - 1, value))
            }
            Cons(head, tail) => {
                if idx == 0 {
                    return Cons(value, tail)
                }
                return Cons(head, set_at_index_impl(tail, idx - 1, value))
            }
        }
    }

/// Checks if a path exists in the JSON value.
pub let has_path: fn(Json, string) -> bool = fn(json: Json, path: string) -> bool {
    match get_path(json, path) {
        Some(_) => { return true }
        None => { return false }
    }
}

/// Removes the value at the given path.
/// Returns the modified JSON. If the path doesn't exist, returns the original JSON.
pub let remove_path: fn(Json, string) -> Json = fn(json: Json, path: string) -> Json {
    if std.string.length(path) == 0 {
        return JNull
    }
    let segments_result: Result[List[PathSegment], PathError] = parse_path(path)
    match segments_result {
        Err(_) => { return json }
        Ok(segments) => { return remove_path_segments(json, segments) }
    }
}

/// Removes a value using parsed path segments.
let remove_path_segments: fn(Json, List[PathSegment]) -> Json =
    fn(json: Json, segments: List[PathSegment]) -> Json {
        match segments {
            Nil => { return json }
            Cons(segment, rest) => {
                match rest {
                    Nil => {
                        // Last segment - remove this key/index
                        match segment {
                            PathKey(key) => { return remove_field(json, key) }
                            PathIndex(idx) => {
                                match json {
                                    JArray(arr) => { return JArray(remove_at_index(arr, idx)) }
                                    _ => { return json }
                                }
                            }
                        }
                    }
                    _ => {
                        // Not last segment - recurse
                        match segment {
                            PathKey(key) => {
                                match get_field(json, key) {
                                    None => { return json }
                                    Some(nested) => {
                                        let new_nested: Json = remove_path_segments(nested, rest)
                                        return set_field(json, key, new_nested)
                                    }
                                }
                            }
                            PathIndex(idx) => {
                                match get_index(json, idx) {
                                    None => { return json }
                                    Some(nested) => {
                                        let new_nested: Json = remove_path_segments(nested, rest)
                                        match json {
                                            JArray(arr) => { return JArray(set_at_index(arr, idx, new_nested)) }
                                            _ => { return json }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

/// Removes an element at an index from a list.
let remove_at_index: fn(List[Json], i32) -> List[Json] =
    fn(arr: List[Json], idx: i32) -> List[Json] {
        if idx < 0 {
            return arr
        }
        match arr {
            Nil => { return Nil }
            Cons(head, tail) => {
                if idx == 0 {
                    return tail
                }
                return Cons(head, remove_at_index(tail, idx - 1))
            }
        }
    }

// =============================================================================
// Convenience Constructors
// =============================================================================

/// Creates a JSON null value.
pub let json_null: fn() -> Json = fn() -> Json {
    return JNull
}

/// Creates a JSON boolean value.
pub let json_bool: fn(bool) -> Json = fn(b: bool) -> Json {
    return JBool(b)
}

/// Creates a JSON number value from a float.
pub let json_number: fn(f64) -> Json = fn(n: f64) -> Json {
    return JNumber(n)
}

/// Creates a JSON number value from an integer.
pub let json_int: fn(i64) -> Json = fn(n: i64) -> Json {
    return JNumber(std.float.from_int(n))
}

/// Creates a JSON string value.
pub let json_string: fn(string) -> Json = fn(s: string) -> Json {
    return JString(s)
}

/// Creates a JSON array from a list of JSON values.
pub let json_array: fn(List[Json]) -> Json = fn(items: List[Json]) -> Json {
    return JArray(items)
}

/// Creates an empty JSON array.
pub let json_array_empty: fn() -> Json = fn() -> Json {
    return JArray(Nil)
}

/// Creates a JSON object from a list of fields.
/// Converts the List[JsonField] to internal HashMap representation.
pub let json_object: fn(List[JsonField]) -> Json = fn(fields: List[JsonField]) -> Json {
    return JObject(fields_to_hashmap(fields))
}

/// Creates a JSON object from a HashMap.
pub let json_object_from_map: fn(HashMap) -> Json = fn(map: HashMap) -> Json {
    return JObject(map)
}

/// Creates an empty JSON object.
pub let json_object_empty: fn() -> Json = fn() -> Json {
    return JObject(std.map.new())
}

// =============================================================================
// Builder Pattern
// =============================================================================

/// A builder for constructing JSON objects fluently.
pub type JsonBuilder = {
    fields: List[JsonField]
}

/// Creates a new empty JSON object builder.
pub let builder: fn() -> JsonBuilder = fn() -> JsonBuilder {
    return JsonBuilder { fields: Nil }
}

/// Adds a field to the builder.
pub let with_field: fn(JsonBuilder, string, Json) -> JsonBuilder =
    fn(b: JsonBuilder, key: string, value: Json) -> JsonBuilder {
        return JsonBuilder { fields: Cons(JsonField { key: key, value: value }, b.fields) }
    }

/// Adds a string field to the builder.
pub let with_string: fn(JsonBuilder, string, string) -> JsonBuilder =
    fn(b: JsonBuilder, key: string, value: string) -> JsonBuilder {
        return with_field(b, key, JString(value))
    }

/// Adds a number field to the builder.
pub let with_number: fn(JsonBuilder, string, f64) -> JsonBuilder =
    fn(b: JsonBuilder, key: string, value: f64) -> JsonBuilder {
        return with_field(b, key, JNumber(value))
    }

/// Adds an integer field to the builder.
pub let with_int: fn(JsonBuilder, string, i64) -> JsonBuilder =
    fn(b: JsonBuilder, key: string, value: i64) -> JsonBuilder {
        return with_field(b, key, JNumber(std.float.from_int(value)))
    }

/// Adds a boolean field to the builder.
pub let with_bool: fn(JsonBuilder, string, bool) -> JsonBuilder =
    fn(b: JsonBuilder, key: string, value: bool) -> JsonBuilder {
        return with_field(b, key, JBool(value))
    }

/// Adds a null field to the builder.
pub let with_null: fn(JsonBuilder, string) -> JsonBuilder =
    fn(b: JsonBuilder, key: string) -> JsonBuilder {
        return with_field(b, key, JNull)
    }

/// Adds an array field to the builder.
pub let with_array: fn(JsonBuilder, string, List[Json]) -> JsonBuilder =
    fn(b: JsonBuilder, key: string, items: List[Json]) -> JsonBuilder {
        return with_field(b, key, JArray(items))
    }

/// Adds an object field to the builder (from another builder).
pub let with_object: fn(JsonBuilder, string, JsonBuilder) -> JsonBuilder =
    fn(b: JsonBuilder, key: string, nested: JsonBuilder) -> JsonBuilder {
        return with_field(b, key, build(nested))
    }

/// Builds the final JSON object from the builder.
/// Fields are in reverse order of addition (last added is first).
pub let build: fn(JsonBuilder) -> Json = fn(b: JsonBuilder) -> Json {
    return JObject(fields_to_hashmap(reverse_fields(b.fields)))
}

/// Reverses a list of fields to maintain insertion order.
let reverse_fields: fn(List[JsonField]) -> List[JsonField] =
    fn(fields: List[JsonField]) -> List[JsonField] {
        return reverse_fields_acc(fields, Nil)
    }

let reverse_fields_acc: fn(List[JsonField], List[JsonField]) -> List[JsonField] =
    fn(fields: List[JsonField], acc: List[JsonField]) -> List[JsonField] {
        match fields {
            Nil => { return acc }
            Cons(head, tail) => { return reverse_fields_acc(tail, Cons(head, acc)) }
        }
    }

// =============================================================================
// Error Context Formatting
// =============================================================================

/// Formats an error with context from the input string.
/// Shows the line where the error occurred with a column indicator.
pub let format_error_with_context: fn(string, JsonError) -> string =
    fn(input: string, err: JsonError) -> string {
        let line_num: i32 = error_line(err)
        let col_num: i32 = error_column(err)
        let error_msg: string = format_error(err)

        // Get the line content
        let line_content: string = get_line_at(input, line_num)

        // Build the column indicator
        let indicator: string = build_indicator(col_num)

        // Combine everything
        let sb: StringBuilder = std.builder.new()
        let sb2: StringBuilder = std.builder.append(sb, error_msg)
        let sb3: StringBuilder = std.builder.append(sb2, "\n")
        let sb4: StringBuilder = std.builder.append(sb3, line_content)
        let sb5: StringBuilder = std.builder.append(sb4, "\n")
        let sb6: StringBuilder = std.builder.append(sb5, indicator)
        return std.builder.build(sb6)
    }

/// Gets a specific line from the input (1-indexed).
let get_line_at: fn(string, i32) -> string = fn(input: string, target_line: i32) -> string {
    let lines: List[string] = split_lines(input)
    return get_nth_line(lines, target_line, 1)
}

let get_nth_line: fn(List[string], i32, i32) -> string =
    fn(lines: List[string], target: i32, current: i32) -> string {
        match lines {
            Nil => { return "" }
            Cons(line, rest) => {
                if current == target {
                    return line
                }
                return get_nth_line(rest, target, current + 1)
            }
        }
    }

/// Splits a string into lines.
let split_lines: fn(string) -> List[string] = fn(input: string) -> List[string] {
    return split_lines_acc(input, 0, std.builder.new())
}

let split_lines_acc: fn(string, i32, StringBuilder) -> List[string] =
    fn(input: string, pos: i32, current: StringBuilder) -> List[string] {
        let len: i32 = std.string.length(input)
        if pos >= len {
            let final_line: string = std.builder.build(current)
            if std.string.length(final_line) > 0 {
                return Cons(final_line, Nil)
            }
            return Nil
        }
        let c: string = std.string.substring(input, pos, pos + 1)
        if std.string.equals(c, "\n") {
            let line: string = std.builder.build(current)
            return Cons(line, split_lines_acc(input, pos + 1, std.builder.new()))
        }
        if std.string.equals(c, "\r") {
            // Handle \r\n
            let next_pos: i32 = pos + 1
            if next_pos < len {
                let next_c: string = std.string.substring(input, next_pos, next_pos + 1)
                if std.string.equals(next_c, "\n") {
                    let line: string = std.builder.build(current)
                    return Cons(line, split_lines_acc(input, pos + 2, std.builder.new()))
                }
            }
            let line: string = std.builder.build(current)
            return Cons(line, split_lines_acc(input, pos + 1, std.builder.new()))
        }
        let new_current: StringBuilder = std.builder.append(current, c)
        return split_lines_acc(input, pos + 1, new_current)
    }

/// Builds a column indicator string (spaces followed by ^).
let build_indicator: fn(i32) -> string = fn(col: i32) -> string {
    let spaces: string = repeat_char(" ", col - 1)
    return std.string.concat(spaces, "^")
}

/// Repeats a character n times.
let repeat_char: fn(string, i32) -> string = fn(c: string, n: i32) -> string {
    if n <= 0 {
        return ""
    }
    let sb: StringBuilder = std.builder.new()
    return repeat_char_acc(sb, c, n)
}

let repeat_char_acc: fn(StringBuilder, string, i32) -> string =
    fn(sb: StringBuilder, c: string, n: i32) -> string {
        if n <= 0 {
            return std.builder.build(sb)
        }
        let new_sb: StringBuilder = std.builder.append(sb, c)
        return repeat_char_acc(new_sb, c, n - 1)
    }

