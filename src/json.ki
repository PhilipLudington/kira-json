/// JSON Parser Library for Kira
/// A pure functional JSON parsing, manipulation, and serialization library.

module json

// =============================================================================
// Core Types
// =============================================================================

/// Represents a JSON value.
/// JSON can be null, boolean, number, string, array, or object.
pub type Json =
    | JNull
    | JBool(bool)
    | JNumber(f64)
    | JString(string)
    | JArray(List[Json])
    | JObject(List[JsonField])

/// A key-value pair in a JSON object.
pub type JsonField = {
    key: string,
    value: Json
}

/// Creates a JsonField from a key and value.
pub let make_field: fn(string, Json) -> JsonField = fn(key: string, value: Json) -> JsonField {
    return JsonField { key: key, value: value }
}

/// Error information from parsing, including position in the input.
pub type ParseError = {
    message: string,
    line: i32,
    column: i32
}


/// Internal state for the recursive descent parser.
type ParserState = {
    input: string,
    pos: i32,
    line: i32,
    column: i32
}

/// Result of a parse operation - either success with value and new state,
/// or failure with an error.
type ParseResult[T] =
    | ParseOk(T, ParserState)
    | ParseErr(ParseError)

// =============================================================================
// Type Checking Predicates
// =============================================================================

/// Returns true if the JSON value is null.
pub let is_null: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JNull => { return true }
        _ => { return false }
    }
}

/// Returns true if the JSON value is a boolean.
pub let is_bool: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JBool(_) => { return true }
        _ => { return false }
    }
}

/// Returns true if the JSON value is a number.
pub let is_number: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JNumber(_) => { return true }
        _ => { return false }
    }
}

/// Returns true if the JSON value is a string.
pub let is_string: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JString(_) => { return true }
        _ => { return false }
    }
}

/// Returns true if the JSON value is an array.
pub let is_array: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JArray(_) => { return true }
        _ => { return false }
    }
}

/// Returns true if the JSON value is an object.
pub let is_object: fn(Json) -> bool = fn(json: Json) -> bool {
    match json {
        JObject(_) => { return true }
        _ => { return false }
    }
}

/// Returns the type name of a JSON value as a string.
pub let type_name: fn(Json) -> string = fn(json: Json) -> string {
    match json {
        JNull => { return "null" }
        JBool(_) => { return "boolean" }
        JNumber(_) => { return "number" }
        JString(_) => { return "string" }
        JArray(_) => { return "array" }
        JObject(_) => { return "object" }
    }
}

// =============================================================================
// Value Extractors
// =============================================================================

/// Extracts the string value if the JSON is a string.
pub let as_string: fn(Json) -> Option[string] = fn(json: Json) -> Option[string] {
    match json {
        JString(s) => { return Some(s) }
        _ => { return None }
    }
}

/// Extracts the number value if the JSON is a number.
pub let as_number: fn(Json) -> Option[f64] = fn(json: Json) -> Option[f64] {
    match json {
        JNumber(n) => { return Some(n) }
        _ => { return None }
    }
}

/// Extracts the number as an integer if the JSON is a number.
/// Truncates the number towards zero.
pub let as_int: fn(Json) -> Option[i64] = fn(json: Json) -> Option[i64] {
    match json {
        JNumber(n) => { return Some(std.math.trunc_to_i64(n)) }
        _ => { return None }
    }
}

/// Extracts the boolean value if the JSON is a boolean.
pub let as_bool: fn(Json) -> Option[bool] = fn(json: Json) -> Option[bool] {
    match json {
        JBool(b) => { return Some(b) }
        _ => { return None }
    }
}

/// Extracts the array if the JSON is an array.
pub let as_array: fn(Json) -> Option[List[Json]] = fn(json: Json) -> Option[List[Json]] {
    match json {
        JArray(arr) => { return Some(arr) }
        _ => { return None }
    }
}

/// Extracts the object fields if the JSON is an object.
pub let as_object: fn(Json) -> Option[List[JsonField]] = fn(json: Json) -> Option[List[JsonField]] {
    match json {
        JObject(fields) => { return Some(fields) }
        _ => { return None }
    }
}

// =============================================================================
// Field/Index Accessors
// =============================================================================

/// Gets a field value from a JSON object by key.
/// Returns None if not an object or key not found.
pub let get_field: fn(Json, string) -> Option[Json] = fn(json: Json, key: string) -> Option[Json] {
    match json {
        JObject(fields) => { return find_field(fields, key) }
        _ => { return None }
    }
}

/// Helper to find a field in a list of JsonFields.
let find_field: fn(List[JsonField], string) -> Option[Json] =
    fn(fields: List[JsonField], key: string) -> Option[Json] {
        match fields {
            Nil => { return None }
            Cons(field, rest) => {
                if std.string.equals(field.key, key) {
                    return Some(field.value)
                }
                return find_field(rest, key)
            }
        }
    }

/// Gets an element from a JSON array by index.
/// Returns None if not an array or index out of bounds.
pub let get_index: fn(Json, i32) -> Option[Json] = fn(json: Json, index: i32) -> Option[Json] {
    match json {
        JArray(arr) => { return list_get(arr, index) }
        _ => { return None }
    }
}

/// Helper to get an element from a list by index.
let list_get: fn(List[Json], i32) -> Option[Json] = fn(list: List[Json], index: i32) -> Option[Json] {
    if index < 0 {
        return None
    }
    match list {
        Nil => { return None }
        Cons(head, tail) => {
            if index == 0 {
                return Some(head)
            }
            return list_get(tail, index - 1)
        }
    }
}

/// Returns the size of a JSON array or object.
/// Returns None for other types.
pub let size: fn(Json) -> Option[i32] = fn(json: Json) -> Option[i32] {
    match json {
        JArray(arr) => { return Some(list_length[Json](arr)) }
        JObject(fields) => { return Some(list_length[JsonField](fields)) }
        _ => { return None }
    }
}

/// Helper to get the length of a list.
let list_length[T]: fn(List[T]) -> i32 = fn(list: List[T]) -> i32 {
    match list {
        Nil => { return 0 }
        Cons(_, tail) => { return 1 + list_length[T](tail) }
    }
}

/// Returns the keys of a JSON object.
/// Returns None if not an object.
pub let keys: fn(Json) -> Option[List[string]] = fn(json: Json) -> Option[List[string]] {
    match json {
        JObject(fields) => { return Some(extract_keys(fields)) }
        _ => { return None }
    }
}

/// Helper to extract keys from a list of JsonFields.
let extract_keys: fn(List[JsonField]) -> List[string] = fn(fields: List[JsonField]) -> List[string] {
    match fields {
        Nil => { return Nil }
        Cons(field, rest) => { return Cons(field.key, extract_keys(rest)) }
    }
}

/// Returns the values of a JSON object.
/// Returns None if not an object.
pub let values: fn(Json) -> Option[List[Json]] = fn(json: Json) -> Option[List[Json]] {
    match json {
        JObject(fields) => { return Some(extract_values(fields)) }
        _ => { return None }
    }
}

/// Helper to extract values from a list of JsonFields.
let extract_values: fn(List[JsonField]) -> List[Json] = fn(fields: List[JsonField]) -> List[Json] {
    match fields {
        Nil => { return Nil }
        Cons(field, rest) => { return Cons(field.value, extract_values(rest)) }
    }
}

// =============================================================================
// Serializer - String Escaping
// =============================================================================

/// Escapes a string for JSON output.
/// Uses std.string.chars for proper character iteration.
let escape_string: fn(string) -> string = fn(s: string) -> string {
    let chars: List[Char] = std.string.chars(s)
    let builder: StringBuilder = escape_chars_to_builder(chars, std.builder.new())
    return std.builder.build(builder)
}

/// Helper to escape characters into a StringBuilder.
let escape_chars_to_builder: fn(List[Char], StringBuilder) -> StringBuilder =
    fn(chars: List[Char], builder: StringBuilder) -> StringBuilder {
        match chars {
            Nil => { return builder }
            Cons(c, rest) => {
                let escaped_builder: StringBuilder = escape_char(c, builder)
                return escape_chars_to_builder(rest, escaped_builder)
            }
        }
    }

/// Escapes a single character into a StringBuilder.
/// Properly handles control characters using std.char.to_i32.
let escape_char: fn(Char, StringBuilder) -> StringBuilder = fn(c: Char, builder: StringBuilder) -> StringBuilder {
    let code: i32 = std.char.to_i32(c)

    // Check for characters that need escaping
    if code == 34 {  // Double quote "
        return std.builder.append(builder, "\\\"")
    }
    if code == 92 {  // Backslash \
        return std.builder.append(builder, "\\\\")
    }
    if code == 8 {   // Backspace \b
        return std.builder.append(builder, "\\b")
    }
    if code == 12 {  // Form feed \f
        return std.builder.append(builder, "\\f")
    }
    if code == 10 {  // Newline \n
        return std.builder.append(builder, "\\n")
    }
    if code == 13 {  // Carriage return \r
        return std.builder.append(builder, "\\r")
    }
    if code == 9 {   // Tab \t
        return std.builder.append(builder, "\\t")
    }

    // Escape other control characters (0x00-0x1F) as \uXXXX
    if code < 32 {
        return append_unicode_escape(builder, code)
    }

    // Regular character - append as-is
    return std.builder.append_char(builder, c)
}

/// Appends a \uXXXX escape sequence to the builder.
let append_unicode_escape: fn(StringBuilder, i32) -> StringBuilder = fn(builder: StringBuilder, code: i32) -> StringBuilder {
    let b1: StringBuilder = std.builder.append(builder, "\\u")
    let b2: StringBuilder = std.builder.append(b1, hex_digit_char((code / 4096) % 16))
    let b3: StringBuilder = std.builder.append(b2, hex_digit_char((code / 256) % 16))
    let b4: StringBuilder = std.builder.append(b3, hex_digit_char((code / 16) % 16))
    let b5: StringBuilder = std.builder.append(b4, hex_digit_char(code % 16))
    return b5
}

/// Converts a hex digit value (0-15) to its character representation.
let hex_digit_char: fn(i32) -> string = fn(n: i32) -> string {
    if n == 0 { return "0" }
    if n == 1 { return "1" }
    if n == 2 { return "2" }
    if n == 3 { return "3" }
    if n == 4 { return "4" }
    if n == 5 { return "5" }
    if n == 6 { return "6" }
    if n == 7 { return "7" }
    if n == 8 { return "8" }
    if n == 9 { return "9" }
    if n == 10 { return "a" }
    if n == 11 { return "b" }
    if n == 12 { return "c" }
    if n == 13 { return "d" }
    if n == 14 { return "e" }
    return "f"
}

/// Pads a string on the left to the specified length.
let pad_left_str: fn(string, i32, string) -> string = fn(s: string, len: i32, pad: string) -> string {
    let current_len: i32 = std.string.length(s)
    if current_len >= len {
        return s
    }
    return pad_left_str(std.string.concat(pad, s), len, pad)
}

// =============================================================================
// Serializer - Stringify
// =============================================================================

/// Converts a JSON value to a compact string representation.
/// Uses StringBuilder for efficient string building.
pub let stringify: fn(Json) -> string = fn(json: Json) -> string {
    let builder: StringBuilder = stringify_to_builder(json, std.builder.new())
    return std.builder.build(builder)
}

/// Stringifies a JSON value into a StringBuilder.
let stringify_to_builder: fn(Json, StringBuilder) -> StringBuilder = fn(json: Json, builder: StringBuilder) -> StringBuilder {
    match json {
        JNull => { return std.builder.append(builder, "null") }
        JBool(b) => {
            if b {
                return std.builder.append(builder, "true")
            }
            return std.builder.append(builder, "false")
        }
        JNumber(n) => { return std.builder.append(builder, std.float.to_string(n)) }
        JString(s) => {
            let b1: StringBuilder = std.builder.append(builder, "\"")
            let b2: StringBuilder = std.builder.append(b1, escape_string(s))
            return std.builder.append(b2, "\"")
        }
        JArray(arr) => { return stringify_array_to_builder(arr, builder) }
        JObject(fields) => { return stringify_object_to_builder(fields, builder) }
    }
}

/// Stringifies an array into a StringBuilder.
let stringify_array_to_builder: fn(List[Json], StringBuilder) -> StringBuilder = fn(arr: List[Json], builder: StringBuilder) -> StringBuilder {
    let b1: StringBuilder = std.builder.append(builder, "[")
    let b2: StringBuilder = stringify_array_contents_to_builder(arr, b1, true)
    return std.builder.append(b2, "]")
}

/// Stringifies array contents with comma separation into a StringBuilder.
let stringify_array_contents_to_builder: fn(List[Json], StringBuilder, bool) -> StringBuilder =
    fn(arr: List[Json], builder: StringBuilder, is_first: bool) -> StringBuilder {
        match arr {
            Nil => { return builder }
            Cons(elem, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",")
                }
                let b2: StringBuilder = stringify_to_builder(elem, b)
                return stringify_array_contents_to_builder(rest, b2, false)
            }
        }
    }

/// Stringifies an object into a StringBuilder.
let stringify_object_to_builder: fn(List[JsonField], StringBuilder) -> StringBuilder = fn(fields: List[JsonField], builder: StringBuilder) -> StringBuilder {
    let b1: StringBuilder = std.builder.append(builder, "{")
    let b2: StringBuilder = stringify_object_contents_to_builder(fields, b1, true)
    return std.builder.append(b2, "}")
}

/// Stringifies object contents with comma separation into a StringBuilder.
let stringify_object_contents_to_builder: fn(List[JsonField], StringBuilder, bool) -> StringBuilder =
    fn(fields: List[JsonField], builder: StringBuilder, is_first: bool) -> StringBuilder {
        match fields {
            Nil => { return builder }
            Cons(field, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",")
                }
                let b1: StringBuilder = std.builder.append(b, "\"")
                let b2: StringBuilder = std.builder.append(b1, escape_string(field.key))
                let b3: StringBuilder = std.builder.append(b2, "\":")
                let b4: StringBuilder = stringify_to_builder(field.value, b3)
                return stringify_object_contents_to_builder(rest, b4, false)
            }
        }
    }

/// Converts a JSON value to a pretty-printed string with 2-space indentation.
/// Uses StringBuilder for efficient string building.
pub let stringify_pretty: fn(Json) -> string = fn(json: Json) -> string {
    return stringify_pretty_with(json, 2)
}

/// Converts a JSON value to a pretty-printed string with custom indentation.
pub let stringify_pretty_with: fn(Json, i32) -> string = fn(json: Json, indent_size: i32) -> string {
    let builder: StringBuilder = stringify_indent_to_builder(json, 0, indent_size, std.builder.new())
    return std.builder.build(builder)
}

/// Stringifies with indentation at the current level into a StringBuilder.
let stringify_indent_to_builder: fn(Json, i32, i32, StringBuilder) -> StringBuilder =
    fn(json: Json, level: i32, indent_size: i32, builder: StringBuilder) -> StringBuilder {
        match json {
            JNull => { return std.builder.append(builder, "null") }
            JBool(b) => {
                if b {
                    return std.builder.append(builder, "true")
                }
                return std.builder.append(builder, "false")
            }
            JNumber(n) => { return std.builder.append(builder, std.float.to_string(n)) }
            JString(s) => {
                let b1: StringBuilder = std.builder.append(builder, "\"")
                let b2: StringBuilder = std.builder.append(b1, escape_string(s))
                return std.builder.append(b2, "\"")
            }
            JArray(arr) => { return stringify_array_pretty_to_builder(arr, level, indent_size, builder) }
            JObject(fields) => { return stringify_object_pretty_to_builder(fields, level, indent_size, builder) }
        }
    }

/// Appends indentation (spaces) to a StringBuilder.
let append_indent: fn(StringBuilder, i32, i32) -> StringBuilder =
    fn(builder: StringBuilder, level: i32, indent_size: i32) -> StringBuilder {
        let total_spaces: i32 = level * indent_size
        return append_spaces(builder, total_spaces)
    }

/// Appends n spaces to a StringBuilder.
let append_spaces: fn(StringBuilder, i32) -> StringBuilder = fn(builder: StringBuilder, n: i32) -> StringBuilder {
    if n <= 0 {
        return builder
    }
    return append_spaces(std.builder.append(builder, " "), n - 1)
}

/// Pretty-prints an array into a StringBuilder.
let stringify_array_pretty_to_builder: fn(List[Json], i32, i32, StringBuilder) -> StringBuilder =
    fn(arr: List[Json], level: i32, indent_size: i32, builder: StringBuilder) -> StringBuilder {
        match arr {
            Nil => { return std.builder.append(builder, "[]") }
            _ => {
                let b1: StringBuilder = std.builder.append(builder, "[\n")
                let b2: StringBuilder = stringify_array_contents_pretty_to_builder(arr, level + 1, indent_size, b1, true)
                let b3: StringBuilder = std.builder.append(b2, "\n")
                let b4: StringBuilder = append_indent(b3, level, indent_size)
                return std.builder.append(b4, "]")
            }
        }
    }

/// Pretty-prints array contents into a StringBuilder.
let stringify_array_contents_pretty_to_builder: fn(List[Json], i32, i32, StringBuilder, bool) -> StringBuilder =
    fn(arr: List[Json], level: i32, indent_size: i32, builder: StringBuilder, is_first: bool) -> StringBuilder {
        match arr {
            Nil => { return builder }
            Cons(elem, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",\n")
                }
                let b1: StringBuilder = append_indent(b, level, indent_size)
                let b2: StringBuilder = stringify_indent_to_builder(elem, level, indent_size, b1)
                return stringify_array_contents_pretty_to_builder(rest, level, indent_size, b2, false)
            }
        }
    }

/// Pretty-prints an object into a StringBuilder.
let stringify_object_pretty_to_builder: fn(List[JsonField], i32, i32, StringBuilder) -> StringBuilder =
    fn(fields: List[JsonField], level: i32, indent_size: i32, builder: StringBuilder) -> StringBuilder {
        match fields {
            Nil => { return std.builder.append(builder, "{}") }
            _ => {
                let b1: StringBuilder = std.builder.append(builder, "{\n")
                let b2: StringBuilder = stringify_object_contents_pretty_to_builder(fields, level + 1, indent_size, b1, true)
                let b3: StringBuilder = std.builder.append(b2, "\n")
                let b4: StringBuilder = append_indent(b3, level, indent_size)
                return std.builder.append(b4, "}")
            }
        }
    }

/// Pretty-prints object contents into a StringBuilder.
let stringify_object_contents_pretty_to_builder: fn(List[JsonField], i32, i32, StringBuilder, bool) -> StringBuilder =
    fn(fields: List[JsonField], level: i32, indent_size: i32, builder: StringBuilder, is_first: bool) -> StringBuilder {
        match fields {
            Nil => { return builder }
            Cons(field, rest) => {
                var b: StringBuilder = builder
                if not is_first {
                    b = std.builder.append(b, ",\n")
                }
                let b1: StringBuilder = append_indent(b, level, indent_size)
                let b2: StringBuilder = std.builder.append(b1, "\"")
                let b3: StringBuilder = std.builder.append(b2, escape_string(field.key))
                let b4: StringBuilder = std.builder.append(b3, "\": ")
                let b5: StringBuilder = stringify_indent_to_builder(field.value, level, indent_size, b4)
                return stringify_object_contents_pretty_to_builder(rest, level, indent_size, b5, false)
            }
        }
    }

// =============================================================================
// Parser - State Utilities
// =============================================================================

/// Creates an initial parser state from an input string.
let init_state: fn(string) -> ParserState = fn(input: string) -> ParserState {
    return ParserState {
        input: input,
        pos: 0,
        line: 1,
        column: 1
    }
}

/// Creates a parse error with the current position.
let make_error: fn(ParserState, string) -> ParseError = fn(state: ParserState, message: string) -> ParseError {
    return ParseError {
        message: message,
        line: state.line,
        column: state.column
    }
}

/// Returns true if the parser has reached the end of input.
let is_eof: fn(ParserState) -> bool = fn(state: ParserState) -> bool {
    return state.pos >= std.string.length(state.input)
}

/// Returns the current character as a string without consuming it.
let peek_str: fn(ParserState) -> Option[string] = fn(state: ParserState) -> Option[string] {
    if is_eof(state) {
        return None
    }
    return Some(std.string.substring(state.input, state.pos, state.pos + 1))
}

/// Returns the character at a given offset as a string.
let peek_at_str: fn(ParserState, i32) -> Option[string] = fn(state: ParserState, offset: i32) -> Option[string] {
    let target_pos: i32 = state.pos + offset
    if target_pos >= std.string.length(state.input) {
        return None
    }
    return Some(std.string.substring(state.input, target_pos, target_pos + 1))
}

/// Advances the parser by one character, updating line/column tracking.
let advance: fn(ParserState) -> ParserState = fn(state: ParserState) -> ParserState {
    if is_eof(state) {
        return state
    }
    let c: string = std.string.substring(state.input, state.pos, state.pos + 1)
    var new_line: i32 = state.line
    var new_column: i32 = state.column
    if std.string.equals(c, "\n") {
        new_line = state.line + 1
        new_column = 1
    } else {
        new_column = state.column + 1
    }
    return ParserState {
        input: state.input,
        pos: state.pos + 1,
        line: new_line,
        column: new_column
    }
}

/// Skips whitespace characters.
let skip_whitespace: fn(ParserState) -> ParserState = fn(state: ParserState) -> ParserState {
    match peek_str(state) {
        None => { return state }
        Some(c) => {
            if is_whitespace_str(c) {
                return skip_whitespace(advance(state))
            }
            return state
        }
    }
}

/// Returns true if the string is a whitespace character.
let is_whitespace_str: fn(string) -> bool = fn(c: string) -> bool {
    return std.string.equals(c, " ") or std.string.equals(c, "\t") or
           std.string.equals(c, "\n") or std.string.equals(c, "\r")
}

// =============================================================================
// Parser - Character Utilities (String-Based)
// =============================================================================

/// Returns true if the string (single char) is a digit (0-9).
let is_digit_str: fn(string) -> bool = fn(c: string) -> bool {
    return std.string.equals(c, "0") or std.string.equals(c, "1") or
           std.string.equals(c, "2") or std.string.equals(c, "3") or
           std.string.equals(c, "4") or std.string.equals(c, "5") or
           std.string.equals(c, "6") or std.string.equals(c, "7") or
           std.string.equals(c, "8") or std.string.equals(c, "9")
}

/// Returns true if the string (single char) is a hex digit (0-9, a-f, A-F).
let is_hex_digit_str: fn(string) -> bool = fn(c: string) -> bool {
    return is_digit_str(c) or
           std.string.equals(c, "a") or std.string.equals(c, "b") or
           std.string.equals(c, "c") or std.string.equals(c, "d") or
           std.string.equals(c, "e") or std.string.equals(c, "f") or
           std.string.equals(c, "A") or std.string.equals(c, "B") or
           std.string.equals(c, "C") or std.string.equals(c, "D") or
           std.string.equals(c, "E") or std.string.equals(c, "F")
}

/// Converts a hex digit string to its integer value.
let hex_digit_value_str: fn(string) -> i32 = fn(c: string) -> i32 {
    if std.string.equals(c, "0") { return 0 }
    if std.string.equals(c, "1") { return 1 }
    if std.string.equals(c, "2") { return 2 }
    if std.string.equals(c, "3") { return 3 }
    if std.string.equals(c, "4") { return 4 }
    if std.string.equals(c, "5") { return 5 }
    if std.string.equals(c, "6") { return 6 }
    if std.string.equals(c, "7") { return 7 }
    if std.string.equals(c, "8") { return 8 }
    if std.string.equals(c, "9") { return 9 }
    if std.string.equals(c, "a") or std.string.equals(c, "A") { return 10 }
    if std.string.equals(c, "b") or std.string.equals(c, "B") { return 11 }
    if std.string.equals(c, "c") or std.string.equals(c, "C") { return 12 }
    if std.string.equals(c, "d") or std.string.equals(c, "D") { return 13 }
    if std.string.equals(c, "e") or std.string.equals(c, "E") { return 14 }
    if std.string.equals(c, "f") or std.string.equals(c, "F") { return 15 }
    return 0
}

// =============================================================================
// Parser - Literal Parsers
// =============================================================================

/// Parses the literal "null".
let parse_null: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    let result: ParseResult[string] = expect_literal(state, "null")
    match result {
        ParseOk(_, new_state) => { return ParseOk(JNull, new_state) }
        ParseErr(e) => { return ParseErr(e) }
    }
}

/// Parses a boolean literal ("true" or "false").
let parse_bool: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    match peek_str(state) {
        Some(c) => {
            if std.string.equals(c, "t") {
                let result: ParseResult[string] = expect_literal(state, "true")
                match result {
                    ParseOk(_, new_state) => { return ParseOk(JBool(true), new_state) }
                    ParseErr(e) => { return ParseErr(e) }
                }
            }
            if std.string.equals(c, "f") {
                let result: ParseResult[string] = expect_literal(state, "false")
                match result {
                    ParseOk(_, new_state) => { return ParseOk(JBool(false), new_state) }
                    ParseErr(e) => { return ParseErr(e) }
                }
            }
            return ParseErr(make_error(state, "Expected 'true' or 'false'"))
        }
        None => { return ParseErr(make_error(state, "Expected 'true' or 'false'")) }
    }
}

/// Expects a specific string literal at the current position.
/// Uses index-based comparison to avoid std.string.to_chars.
let expect_literal: fn(ParserState, string) -> ParseResult[string] =
    fn(state: ParserState, expected: string) -> ParseResult[string] {
        let expected_len: i32 = std.string.length(expected)
        return expect_literal_from(state, expected, 0, expected_len)
    }

/// Helper for expect_literal with index tracking.
let expect_literal_from: fn(ParserState, string, i32, i32) -> ParseResult[string] =
    fn(state: ParserState, expected: string, index: i32, len: i32) -> ParseResult[string] {
        if index >= len {
            return ParseOk(expected, state)
        }
        match peek_str(state) {
            None => {
                return ParseErr(make_error(state, "Unexpected end of input"))
            }
            Some(actual) => {
                let expected_char: string = std.string.substring(expected, index, index + 1)
                if std.string.equals(actual, expected_char) {
                    return expect_literal_from(advance(state), expected, index + 1, len)
                }
                let msg: string = std.string.concat("Expected '", std.string.concat(expected_char, "'"))
                return ParseErr(make_error(state, msg))
            }
        }
    }

// =============================================================================
// Parser - Number Parser
// =============================================================================

/// Parses a JSON number.
let parse_number: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    let start_pos: i32 = state.pos
    var current_state: ParserState = state

    // Handle optional negative sign
    match peek_str(current_state) {
        Some(c) => {
            if std.string.equals(c, "-") {
                current_state = advance(current_state)
            }
        }
        None => {}
    }

    // Parse integer part
    match peek_str(current_state) {
        Some(c) => {
            if std.string.equals(c, "0") {
                current_state = advance(current_state)
            } else if is_digit_str(c) {
                current_state = consume_digits_str(current_state)
            } else {
                return ParseErr(make_error(current_state, "Expected digit"))
            }
        }
        None => { return ParseErr(make_error(current_state, "Expected digit")) }
    }

    // Parse optional fractional part
    match peek_str(current_state) {
        Some(c) => {
            if std.string.equals(c, ".") {
                current_state = advance(current_state)
                match peek_str(current_state) {
                    Some(d) => {
                        if is_digit_str(d) {
                            current_state = consume_digits_str(current_state)
                        } else {
                            return ParseErr(make_error(current_state, "Expected digit after decimal point"))
                        }
                    }
                    None => { return ParseErr(make_error(current_state, "Expected digit after decimal point")) }
                }
            }
        }
        None => {}
    }

    // Parse optional exponent
    match peek_str(current_state) {
        Some(c) => {
            if std.string.equals(c, "e") or std.string.equals(c, "E") {
                current_state = advance(current_state)
                match peek_str(current_state) {
                    Some(sign) => {
                        if std.string.equals(sign, "+") or std.string.equals(sign, "-") {
                            current_state = advance(current_state)
                        }
                    }
                    None => {}
                }
                match peek_str(current_state) {
                    Some(d) => {
                        if is_digit_str(d) {
                            current_state = consume_digits_str(current_state)
                        } else {
                            return ParseErr(make_error(current_state, "Expected digit in exponent"))
                        }
                    }
                    None => { return ParseErr(make_error(current_state, "Expected digit in exponent")) }
                }
            }
        }
        None => {}
    }

    let num_str: string = std.string.substring(state.input, start_pos, current_state.pos)
    match std.float.parse(num_str) {
        Some(n) => { return ParseOk(JNumber(n), current_state) }
        None => { return ParseErr(make_error(state, "Invalid number")) }
    }
}

/// Consumes digits and returns the new state.
let consume_digits_str: fn(ParserState) -> ParserState = fn(state: ParserState) -> ParserState {
    match peek_str(state) {
        Some(c) => {
            if is_digit_str(c) {
                return consume_digits_str(advance(state))
            }
            return state
        }
        None => { return state }
    }
}

// =============================================================================
// Parser - String Parser
// =============================================================================

/// Parses a JSON string (including the surrounding quotes).
let parse_string: fn(ParserState) -> ParseResult[string] = fn(state: ParserState) -> ParseResult[string] {
    match peek_str(state) {
        Some(c) => {
            if std.string.equals(c, "\"") {
                let after_quote: ParserState = advance(state)
                return parse_string_contents_str(after_quote, "")
            }
            return ParseErr(make_error(state, "Expected '\"'"))
        }
        None => { return ParseErr(make_error(state, "Expected '\"'")) }
    }
}

/// Parses the contents of a string until the closing quote.
/// Uses StringBuilder for O(n) string building instead of O(nÂ²) concatenation.
let parse_string_contents_str: fn(ParserState, string) -> ParseResult[string] =
    fn(state: ParserState, _acc: string) -> ParseResult[string] {
        let builder: StringBuilder = std.builder.new()
        return parse_string_contents_builder(state, builder)
    }

/// Internal helper that uses StringBuilder for efficient string accumulation.
let parse_string_contents_builder: fn(ParserState, StringBuilder) -> ParseResult[string] =
    fn(state: ParserState, builder: StringBuilder) -> ParseResult[string] {
        match peek_str(state) {
            None => { return ParseErr(make_error(state, "Unterminated string")) }
            Some(c) => {
                if std.string.equals(c, "\"") {
                    return ParseOk(std.builder.build(builder), advance(state))
                }
                if std.string.equals(c, "\\") {
                    let escape_result: ParseResult[string] = parse_escape_sequence_str(advance(state))
                    match escape_result {
                        ParseOk(escaped, new_state) => {
                            let new_builder: StringBuilder = std.builder.append(builder, escaped)
                            return parse_string_contents_builder(new_state, new_builder)
                        }
                        ParseErr(e) => { return ParseErr(e) }
                    }
                }
                // Regular character - add to builder
                let new_builder: StringBuilder = std.builder.append(builder, c)
                return parse_string_contents_builder(advance(state), new_builder)
            }
        }
    }

/// Parses an escape sequence (after the backslash).
/// Returns the escaped character as a string.
let parse_escape_sequence_str: fn(ParserState) -> ParseResult[string] = fn(state: ParserState) -> ParseResult[string] {
    match peek_str(state) {
        None => { return ParseErr(make_error(state, "Unterminated escape sequence")) }
        Some(c) => {
            if std.string.equals(c, "\"") { return ParseOk("\"", advance(state)) }
            if std.string.equals(c, "\\") { return ParseOk("\\", advance(state)) }
            if std.string.equals(c, "/") { return ParseOk("/", advance(state)) }
            if std.string.equals(c, "b") { return ParseOk("\b", advance(state)) }
            if std.string.equals(c, "f") { return ParseOk("\f", advance(state)) }
            if std.string.equals(c, "n") { return ParseOk("\n", advance(state)) }
            if std.string.equals(c, "r") { return ParseOk("\r", advance(state)) }
            if std.string.equals(c, "t") { return ParseOk("\t", advance(state)) }
            if std.string.equals(c, "u") { return parse_unicode_escape_str(advance(state)) }
            let msg: string = std.string.concat("Invalid escape sequence: \\", c)
            return ParseErr(make_error(state, msg))
        }
    }
}

/// Parses a \uXXXX unicode escape sequence.
/// Converts the hex code point to a character using std.char.from_i32.
let parse_unicode_escape_str: fn(ParserState) -> ParseResult[string] = fn(state: ParserState) -> ParseResult[string] {
    var current_state: ParserState = state
    var code_point: i32 = 0

    // Read 4 hex digits and compute code point
    var i: i32 = 0
    while i < 4 {
        match peek_str(current_state) {
            None => { return ParseErr(make_error(current_state, "Incomplete unicode escape")) }
            Some(c) => {
                if not is_hex_digit_str(c) {
                    return ParseErr(make_error(current_state, "Invalid hex digit in unicode escape"))
                }
                code_point = code_point * 16 + hex_digit_value_str(c)
                current_state = advance(current_state)
            }
        }
        i = i + 1
    }

    // Convert code point to character
    match std.char.from_i32(code_point) {
        Some(ch) => {
            // Convert char to single-character string using builder
            let b: StringBuilder = std.builder.new()
            let b2: StringBuilder = std.builder.append_char(b, ch)
            return ParseOk(std.builder.build(b2), current_state)
        }
        None => {
            // Invalid Unicode code point, use replacement character
            return ParseOk("\uFFFD", current_state)
        }
    }
}

// =============================================================================
// Parser - List Utilities
// =============================================================================

/// Reverses a list.
let list_reverse[T]: fn(List[T]) -> List[T] = fn(list: List[T]) -> List[T] {
    return list_reverse_acc[T](list, Nil)
}

/// Reverses a list with an accumulator.
let list_reverse_acc[T]: fn(List[T], List[T]) -> List[T] = fn(list: List[T], acc: List[T]) -> List[T] {
    match list {
        Nil => { return acc }
        Cons(head, tail) => { return list_reverse_acc[T](tail, Cons(head, acc)) }
    }
}

// =============================================================================
// Parser - Compound Parsers
// =============================================================================

/// Parses a JSON array.
let parse_array: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    match peek_str(state) {
        Some(c) => {
            if std.string.equals(c, "[") {
                let after_bracket: ParserState = skip_whitespace(advance(state))
                match peek_str(after_bracket) {
                    Some(c2) => {
                        if std.string.equals(c2, "]") {
                            return ParseOk(JArray(Nil), advance(after_bracket))
                        }
                        return parse_array_elements(after_bracket, Nil)
                    }
                    None => { return parse_array_elements(after_bracket, Nil) }
                }
            }
            return ParseErr(make_error(state, "Expected '['"))
        }
        None => { return ParseErr(make_error(state, "Expected '['")) }
    }
}

/// Parses array elements.
let parse_array_elements: fn(ParserState, List[Json]) -> ParseResult[Json] =
    fn(state: ParserState, acc: List[Json]) -> ParseResult[Json] {
        let value_result: ParseResult[Json] = parse_value(state)
        match value_result {
            ParseErr(e) => { return ParseErr(e) }
            ParseOk(value, after_value) => {
                let new_acc: List[Json] = Cons(value, acc)
                let after_ws: ParserState = skip_whitespace(after_value)
                match peek_str(after_ws) {
                    Some(c) => {
                        if std.string.equals(c, "]") {
                            return ParseOk(JArray(list_reverse[Json](new_acc)), advance(after_ws))
                        }
                        if std.string.equals(c, ",") {
                            let after_comma: ParserState = skip_whitespace(advance(after_ws))
                            return parse_array_elements(after_comma, new_acc)
                        }
                        return ParseErr(make_error(after_ws, "Expected ',' or ']'"))
                    }
                    None => { return ParseErr(make_error(after_ws, "Expected ',' or ']'")) }
                }
            }
        }
    }

/// Parses a JSON object.
let parse_object: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    match peek_str(state) {
        Some(c) => {
            if std.string.equals(c, "{") {
                let after_brace: ParserState = skip_whitespace(advance(state))
                match peek_str(after_brace) {
                    Some(c2) => {
                        if std.string.equals(c2, "}") {
                            return ParseOk(JObject(Nil), advance(after_brace))
                        }
                        return parse_object_fields(after_brace, Nil)
                    }
                    None => { return parse_object_fields(after_brace, Nil) }
                }
            }
            return ParseErr(make_error(state, "Expected '{'"))
        }
        None => { return ParseErr(make_error(state, "Expected '{'")) }
    }
}

/// Parses object fields.
let parse_object_fields: fn(ParserState, List[JsonField]) -> ParseResult[Json] =
    fn(state: ParserState, acc: List[JsonField]) -> ParseResult[Json] {
        // Parse key
        let key_result: ParseResult[string] = parse_string(state)
        match key_result {
            ParseErr(e) => { return ParseErr(e) }
            ParseOk(key, after_key) => {
                let after_key_ws: ParserState = skip_whitespace(after_key)
                // Expect colon
                match peek_str(after_key_ws) {
                    Some(c) => {
                        if std.string.equals(c, ":") {
                            let after_colon: ParserState = skip_whitespace(advance(after_key_ws))
                            // Parse value
                            let value_result: ParseResult[Json] = parse_value(after_colon)
                            match value_result {
                                ParseErr(e) => { return ParseErr(e) }
                                ParseOk(value, after_value) => {
                                    let field: JsonField = JsonField { key: key, value: value }
                                    let new_acc: List[JsonField] = Cons(field, acc)
                                    let after_ws: ParserState = skip_whitespace(after_value)
                                    match peek_str(after_ws) {
                                        Some(c2) => {
                                            if std.string.equals(c2, "}") {
                                                return ParseOk(JObject(list_reverse[JsonField](new_acc)), advance(after_ws))
                                            }
                                            if std.string.equals(c2, ",") {
                                                let after_comma: ParserState = skip_whitespace(advance(after_ws))
                                                return parse_object_fields(after_comma, new_acc)
                                            }
                                            return ParseErr(make_error(after_ws, "Expected ',' or '}'"))
                                        }
                                        None => { return ParseErr(make_error(after_ws, "Expected ',' or '}'")) }
                                    }
                                }
                            }
                        }
                        return ParseErr(make_error(after_key_ws, "Expected ':'"))
                    }
                    None => { return ParseErr(make_error(after_key_ws, "Expected ':'")) }
                }
            }
        }
    }

// =============================================================================
// Parser - Main Parse Dispatch
// =============================================================================

/// Parses a JSON value based on the first character.
let parse_value: fn(ParserState) -> ParseResult[Json] = fn(state: ParserState) -> ParseResult[Json] {
    let ws_state: ParserState = skip_whitespace(state)
    match peek_str(ws_state) {
        None => { return ParseErr(make_error(ws_state, "Unexpected end of input")) }
        Some(c) => {
            if std.string.equals(c, "n") {
                return parse_null(ws_state)
            }
            if std.string.equals(c, "t") or std.string.equals(c, "f") {
                return parse_bool(ws_state)
            }
            if std.string.equals(c, "\"") {
                let str_result: ParseResult[string] = parse_string(ws_state)
                match str_result {
                    ParseOk(s, new_state) => { return ParseOk(JString(s), new_state) }
                    ParseErr(e) => { return ParseErr(e) }
                }
            }
            if std.string.equals(c, "[") {
                return parse_array(ws_state)
            }
            if std.string.equals(c, "{") {
                return parse_object(ws_state)
            }
            if std.string.equals(c, "-") or is_digit_str(c) {
                return parse_number(ws_state)
            }
            let msg: string = std.string.concat("Unexpected character: ", c)
            return ParseErr(make_error(ws_state, msg))
        }
    }
}

/// Public API: Parses a JSON string into a Json value.
pub let parse: fn(string) -> Result[Json, ParseError] = fn(input: string) -> Result[Json, ParseError] {
    let state: ParserState = init_state(input)
    let result: ParseResult[Json] = parse_value(state)
    match result {
        ParseOk(json, final_state) => {
            let after_ws: ParserState = skip_whitespace(final_state)
            if is_eof(after_ws) {
                return Ok(json)
            }
            return Err(make_error(after_ws, "Unexpected content after JSON value"))
        }
        ParseErr(e) => { return Err(e) }
    }
}

// =============================================================================
// Transformers - Value Mapping
// =============================================================================

/// Recursively applies a function to all JSON values.
pub let map_values: fn(Json, fn(Json) -> Json) -> Json = fn(json: Json, f: fn(Json) -> Json) -> Json {
    let mapped: Json = f(json)
    match mapped {
        JArray(arr) => {
            return JArray(map_list[Json](arr, fn(elem: Json) -> Json { return map_values(elem, f) }))
        }
        JObject(fields) => {
            return JObject(map_list[JsonField](fields, fn(field: JsonField) -> JsonField {
                return JsonField { key: field.key, value: map_values(field.value, f) }
            }))
        }
        _ => { return mapped }
    }
}

/// Maps a function over a list.
let map_list[A]: fn(List[A], fn(A) -> A) -> List[A] = fn(list: List[A], f: fn(A) -> A) -> List[A] {
    match list {
        Nil => { return Nil }
        Cons(head, tail) => { return Cons(f(head), map_list[A](tail, f)) }
    }
}

// =============================================================================
// Transformers - Field Filtering
// =============================================================================

/// Filters object fields at the top level.
pub let filter_fields: fn(Json, fn(string, Json) -> bool) -> Json =
    fn(json: Json, pred: fn(string, Json) -> bool) -> Json {
        match json {
            JObject(fields) => {
                let filtered: List[JsonField] = filter_fields_list(fields, pred)
                return JObject(filtered)
            }
            _ => { return json }
        }
    }

/// Recursively filters object fields at all levels.
pub let filter_fields_deep: fn(Json, fn(string, Json) -> bool) -> Json =
    fn(json: Json, pred: fn(string, Json) -> bool) -> Json {
        match json {
            JArray(arr) => {
                return JArray(map_list[Json](arr, fn(elem: Json) -> Json {
                    return filter_fields_deep(elem, pred)
                }))
            }
            JObject(fields) => {
                let filtered: List[JsonField] = filter_fields_list(fields, pred)
                let deep_filtered: List[JsonField] = map_list[JsonField](filtered, fn(field: JsonField) -> JsonField {
                    return JsonField { key: field.key, value: filter_fields_deep(field.value, pred) }
                })
                return JObject(deep_filtered)
            }
            _ => { return json }
        }
    }

/// Filters a list of JsonFields based on a predicate.
let filter_fields_list: fn(List[JsonField], fn(string, Json) -> bool) -> List[JsonField] =
    fn(fields: List[JsonField], pred: fn(string, Json) -> bool) -> List[JsonField] {
        match fields {
            Nil => { return Nil }
            Cons(field, rest) => {
                if pred(field.key, field.value) {
                    return Cons(field, filter_fields_list(rest, pred))
                }
                return filter_fields_list(rest, pred)
            }
        }
    }

// =============================================================================
// Transformers - Object Operations
// =============================================================================

/// Sets a field in a JSON object. If the key exists, updates it; otherwise adds it.
pub let set_field: fn(Json, string, Json) -> Json = fn(json: Json, key: string, value: Json) -> Json {
    match json {
        JObject(fields) => {
            let updated: List[JsonField] = set_field_in_list(fields, key, value, false)
            return JObject(updated)
        }
        _ => { return json }
    }
}

/// Helper to set a field in a list of JsonFields.
let set_field_in_list: fn(List[JsonField], string, Json, bool) -> List[JsonField] =
    fn(fields: List[JsonField], key: string, value: Json, found: bool) -> List[JsonField] {
        match fields {
            Nil => {
                if found {
                    return Nil
                }
                // Key not found, append new field
                return Cons(JsonField { key: key, value: value }, Nil)
            }
            Cons(field, rest) => {
                if std.string.equals(field.key, key) {
                    // Found the key, update it
                    return Cons(JsonField { key: key, value: value }, set_field_in_list(rest, key, value, true))
                }
                return Cons(field, set_field_in_list(rest, key, value, found))
            }
        }
    }

/// Removes a field from a JSON object.
pub let remove_field: fn(Json, string) -> Json = fn(json: Json, key: string) -> Json {
    match json {
        JObject(fields) => {
            let filtered: List[JsonField] = remove_field_from_list(fields, key)
            return JObject(filtered)
        }
        _ => { return json }
    }
}

/// Helper to remove a field from a list of JsonFields.
let remove_field_from_list: fn(List[JsonField], string) -> List[JsonField] =
    fn(fields: List[JsonField], key: string) -> List[JsonField] {
        match fields {
            Nil => { return Nil }
            Cons(field, rest) => {
                if std.string.equals(field.key, key) {
                    return remove_field_from_list(rest, key)
                }
                return Cons(field, remove_field_from_list(rest, key))
            }
        }
    }

// =============================================================================
// Transformers - Merge Operations
// =============================================================================

/// Shallow merges two JSON values. For objects, b's fields override a's.
pub let merge: fn(Json, Json) -> Json = fn(a: Json, b: Json) -> Json {
    match (a, b) {
        (JObject(fields_a), JObject(fields_b)) => {
            let merged: List[JsonField] = merge_fields(fields_a, fields_b)
            return JObject(merged)
        }
        _ => { return b }
    }
}

/// Merges two field lists, with the second list's fields taking precedence.
let merge_fields: fn(List[JsonField], List[JsonField]) -> List[JsonField] =
    fn(fields_a: List[JsonField], fields_b: List[JsonField]) -> List[JsonField] {
        // Start with fields from a that are not in b, then add all of b
        let a_only: List[JsonField] = filter_fields_not_in(fields_a, fields_b)
        return list_concat[JsonField](a_only, fields_b)
    }

/// Filters fields from the first list that are not present in the second list.
let filter_fields_not_in: fn(List[JsonField], List[JsonField]) -> List[JsonField] =
    fn(fields: List[JsonField], exclude: List[JsonField]) -> List[JsonField] {
        match fields {
            Nil => { return Nil }
            Cons(field, rest) => {
                if has_key(exclude, field.key) {
                    return filter_fields_not_in(rest, exclude)
                }
                return Cons(field, filter_fields_not_in(rest, exclude))
            }
        }
    }

/// Checks if a field list contains a key.
let has_key: fn(List[JsonField], string) -> bool = fn(fields: List[JsonField], key: string) -> bool {
    match fields {
        Nil => { return false }
        Cons(field, rest) => {
            if std.string.equals(field.key, key) {
                return true
            }
            return has_key(rest, key)
        }
    }
}

/// Concatenates two lists.
let list_concat[T]: fn(List[T], List[T]) -> List[T] = fn(a: List[T], b: List[T]) -> List[T] {
    match a {
        Nil => { return b }
        Cons(head, tail) => { return Cons(head, list_concat[T](tail, b)) }
    }
}

/// Deep merges two JSON values. For objects, recursively merges nested objects.
pub let merge_deep: fn(Json, Json) -> Json = fn(a: Json, b: Json) -> Json {
    match (a, b) {
        (JObject(fields_a), JObject(fields_b)) => {
            let merged: List[JsonField] = merge_fields_deep(fields_a, fields_b)
            return JObject(merged)
        }
        _ => { return b }
    }
}

/// Deep merges two field lists.
let merge_fields_deep: fn(List[JsonField], List[JsonField]) -> List[JsonField] =
    fn(fields_a: List[JsonField], fields_b: List[JsonField]) -> List[JsonField] {
        let a_processed: List[JsonField] = map_list[JsonField](fields_a, fn(field_a: JsonField) -> JsonField {
            match find_field(fields_b, field_a.key) {
                Some(value_b) => {
                    return JsonField { key: field_a.key, value: merge_deep(field_a.value, value_b) }
                }
                None => { return field_a }
            }
        })
        let b_only: List[JsonField] = filter_fields_not_in(fields_b, fields_a)
        return list_concat[JsonField](a_processed, b_only)
    }

// =============================================================================
// Transformers - Array Operations
// =============================================================================

/// Maps a function over a JSON array's elements.
pub let map_array: fn(Json, fn(Json) -> Json) -> Json = fn(json: Json, f: fn(Json) -> Json) -> Json {
    match json {
        JArray(arr) => {
            return JArray(map_list[Json](arr, f))
        }
        _ => { return json }
    }
}

/// Filters a JSON array's elements based on a predicate.
pub let filter_array: fn(Json, fn(Json) -> bool) -> Json = fn(json: Json, pred: fn(Json) -> bool) -> Json {
    match json {
        JArray(arr) => {
            return JArray(filter_list[Json](arr, pred))
        }
        _ => { return json }
    }
}

/// Filters a list based on a predicate.
let filter_list[T]: fn(List[T], fn(T) -> bool) -> List[T] = fn(list: List[T], pred: fn(T) -> bool) -> List[T] {
    match list {
        Nil => { return Nil }
        Cons(head, tail) => {
            if pred(head) {
                return Cons(head, filter_list[T](tail, pred))
            }
            return filter_list[T](tail, pred)
        }
    }
}

